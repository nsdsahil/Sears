{"version":3,"file":"rrdom.min.js","sources":["../../rrweb-snapshot/es/rrweb-snapshot.js","../src/style.ts","../src/document.ts","../src/diff.ts","../src/index.ts"],"sourcesContent":["var NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\r\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\r\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\r\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\r\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\r\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\r\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\r\n    return n.nodeType === n.ELEMENT_NODE;\r\n}\r\nfunction isShadowRoot(n) {\r\n    const host = n === null || n === void 0 ? void 0 : n.host;\r\n    return Boolean((host === null || host === void 0 ? void 0 : host.shadowRoot) === n);\r\n}\r\nfunction isNativeShadowDom(shadowRoot) {\r\n    return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\r\n}\r\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\r\n    if (cssText.includes(' background-clip: text;') &&\r\n        !cssText.includes(' -webkit-background-clip: text;')) {\r\n        cssText = cssText.replace(/\\sbackground-clip:\\s*text;/g, ' -webkit-background-clip: text; background-clip: text;');\r\n    }\r\n    return cssText;\r\n}\r\nfunction escapeImportStatement(rule) {\r\n    const { cssText } = rule;\r\n    if (cssText.split('\"').length < 3)\r\n        return cssText;\r\n    const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\r\n    if (rule.layerName === '') {\r\n        statement.push(`layer`);\r\n    }\r\n    else if (rule.layerName) {\r\n        statement.push(`layer(${rule.layerName})`);\r\n    }\r\n    if (rule.supportsText) {\r\n        statement.push(`supports(${rule.supportsText})`);\r\n    }\r\n    if (rule.media.length) {\r\n        statement.push(rule.media.mediaText);\r\n    }\r\n    return statement.join(' ') + ';';\r\n}\r\nfunction stringifyStylesheet(s) {\r\n    try {\r\n        const rules = s.rules || s.cssRules;\r\n        return rules\r\n            ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(''))\r\n            : null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nfunction stringifyRule(rule) {\r\n    let importStringified;\r\n    if (isCSSImportRule(rule)) {\r\n        try {\r\n            importStringified =\r\n                stringifyStylesheet(rule.styleSheet) ||\r\n                    escapeImportStatement(rule);\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\r\n        return fixSafariColons(rule.cssText);\r\n    }\r\n    return importStringified || rule.cssText;\r\n}\r\nfunction fixSafariColons(cssStringified) {\r\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\r\n    return cssStringified.replace(regex, '$1\\\\$2');\r\n}\r\nfunction isCSSImportRule(rule) {\r\n    return 'styleSheet' in rule;\r\n}\r\nfunction isCSSStyleRule(rule) {\r\n    return 'selectorText' in rule;\r\n}\r\nclass Mirror {\r\n    constructor() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n    getId(n) {\r\n        var _a;\r\n        if (!n)\r\n            return -1;\r\n        const id = (_a = this.getMeta(n)) === null || _a === void 0 ? void 0 : _a.id;\r\n        return id !== null && id !== void 0 ? id : -1;\r\n    }\r\n    getNode(id) {\r\n        return this.idNodeMap.get(id) || null;\r\n    }\r\n    getIds() {\r\n        return Array.from(this.idNodeMap.keys());\r\n    }\r\n    getMeta(n) {\r\n        return this.nodeMetaMap.get(n) || null;\r\n    }\r\n    removeNodeFromMap(n) {\r\n        const id = this.getId(n);\r\n        this.idNodeMap.delete(id);\r\n        if (n.childNodes) {\r\n            n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.idNodeMap.has(id);\r\n    }\r\n    hasNode(node) {\r\n        return this.nodeMetaMap.has(node);\r\n    }\r\n    add(n, meta) {\r\n        const id = meta.id;\r\n        this.idNodeMap.set(id, n);\r\n        this.nodeMetaMap.set(n, meta);\r\n    }\r\n    replace(id, n) {\r\n        const oldNode = this.getNode(id);\r\n        if (oldNode) {\r\n            const meta = this.nodeMetaMap.get(oldNode);\r\n            if (meta)\r\n                this.nodeMetaMap.set(n, meta);\r\n        }\r\n        this.idNodeMap.set(id, n);\r\n    }\r\n    reset() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n}\r\nfunction createMirror() {\r\n    return new Mirror();\r\n}\r\nfunction maskInputValue({ element, maskInputOptions, tagName, type, value, maskInputFn, }) {\r\n    let text = value || '';\r\n    const actualType = type && toLowerCase(type);\r\n    if (maskInputOptions[tagName.toLowerCase()] ||\r\n        (actualType && maskInputOptions[actualType])) {\r\n        if (maskInputFn) {\r\n            text = maskInputFn(text, element);\r\n        }\r\n        else {\r\n            text = '*'.repeat(text.length);\r\n        }\r\n    }\r\n    return text;\r\n}\r\nfunction toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\r\nfunction is2DCanvasBlank(canvas) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx)\r\n        return true;\r\n    const chunkSize = 50;\r\n    for (let x = 0; x < canvas.width; x += chunkSize) {\r\n        for (let y = 0; y < canvas.height; y += chunkSize) {\r\n            const getImageData = ctx.getImageData;\r\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\r\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\r\n                : getImageData;\r\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\r\n            if (pixelBuffer.some((pixel) => pixel !== 0))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isNodeMetaEqual(a, b) {\r\n    if (!a || !b || a.type !== b.type)\r\n        return false;\r\n    if (a.type === NodeType.Document)\r\n        return a.compatMode === b.compatMode;\r\n    else if (a.type === NodeType.DocumentType)\r\n        return (a.name === b.name &&\r\n            a.publicId === b.publicId &&\r\n            a.systemId === b.systemId);\r\n    else if (a.type === NodeType.Comment ||\r\n        a.type === NodeType.Text ||\r\n        a.type === NodeType.CDATA)\r\n        return a.textContent === b.textContent;\r\n    else if (a.type === NodeType.Element)\r\n        return (a.tagName === b.tagName &&\r\n            JSON.stringify(a.attributes) ===\r\n                JSON.stringify(b.attributes) &&\r\n            a.isSVG === b.isSVG &&\r\n            a.needBlock === b.needBlock);\r\n    return false;\r\n}\r\nfunction getInputType(element) {\r\n    const type = element.type;\r\n    return element.hasAttribute('data-rr-is-password')\r\n        ? 'password'\r\n        : type\r\n            ?\r\n                toLowerCase(type)\r\n            : null;\r\n}\r\nfunction extractFileExtension(path, baseURL) {\r\n    var _a;\r\n    let url;\r\n    try {\r\n        url = new URL(path, baseURL !== null && baseURL !== void 0 ? baseURL : window.location.href);\r\n    }\r\n    catch (err) {\r\n        return null;\r\n    }\r\n    const regex = /\\.([0-9a-z]+)(?:$)/i;\r\n    const match = url.pathname.match(regex);\r\n    return (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : null;\r\n}\n\nlet _id = 1;\r\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\r\nconst IGNORED_NODE = -2;\r\nfunction genId() {\r\n    return _id++;\r\n}\r\nfunction getValidTagName(element) {\r\n    if (element instanceof HTMLFormElement) {\r\n        return 'form';\r\n    }\r\n    const processedTagName = toLowerCase(element.tagName);\r\n    if (tagNameRegex.test(processedTagName)) {\r\n        return 'div';\r\n    }\r\n    return processedTagName;\r\n}\r\nfunction extractOrigin(url) {\r\n    let origin = '';\r\n    if (url.indexOf('//') > -1) {\r\n        origin = url.split('/').slice(0, 3).join('/');\r\n    }\r\n    else {\r\n        origin = url.split('/')[0];\r\n    }\r\n    origin = origin.split('?')[0];\r\n    return origin;\r\n}\r\nlet canvasService;\r\nlet canvasCtx;\r\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\r\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\r\nconst URL_WWW_MATCH = /^www\\..*/i;\r\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\r\nfunction absoluteToStylesheet(cssText, href) {\r\n    return (cssText || '').replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\r\n        const filePath = path1 || path2 || path3;\r\n        const maybeQuote = quote1 || quote2 || '';\r\n        if (!filePath) {\r\n            return origin;\r\n        }\r\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (DATA_URI.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (filePath[0] === '/') {\r\n            return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\r\n        }\r\n        const stack = href.split('/');\r\n        const parts = filePath.split('/');\r\n        stack.pop();\r\n        for (const part of parts) {\r\n            if (part === '.') {\r\n                continue;\r\n            }\r\n            else if (part === '..') {\r\n                stack.pop();\r\n            }\r\n            else {\r\n                stack.push(part);\r\n            }\r\n        }\r\n        return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\r\n    });\r\n}\r\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\r\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\r\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\r\n    if (attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    let pos = 0;\r\n    function collectCharacters(regEx) {\r\n        let chars;\r\n        const match = regEx.exec(attributeValue.substring(pos));\r\n        if (match) {\r\n            chars = match[0];\r\n            pos += chars.length;\r\n            return chars;\r\n        }\r\n        return '';\r\n    }\r\n    const output = [];\r\n    while (true) {\r\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\r\n        if (pos >= attributeValue.length) {\r\n            break;\r\n        }\r\n        let url = collectCharacters(SRCSET_NOT_SPACES);\r\n        if (url.slice(-1) === ',') {\r\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\r\n            output.push(url);\r\n        }\r\n        else {\r\n            let descriptorsStr = '';\r\n            url = absoluteToDoc(doc, url);\r\n            let inParens = false;\r\n            while (true) {\r\n                const c = attributeValue.charAt(pos);\r\n                if (c === '') {\r\n                    output.push((url + descriptorsStr).trim());\r\n                    break;\r\n                }\r\n                else if (!inParens) {\r\n                    if (c === ',') {\r\n                        pos += 1;\r\n                        output.push((url + descriptorsStr).trim());\r\n                        break;\r\n                    }\r\n                    else if (c === '(') {\r\n                        inParens = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (c === ')') {\r\n                        inParens = false;\r\n                    }\r\n                }\r\n                descriptorsStr += c;\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n    return output.join(', ');\r\n}\r\nconst cachedDocument = new WeakMap();\r\nfunction absoluteToDoc(doc, attributeValue) {\r\n    if (!attributeValue || attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    return getHref(doc, attributeValue);\r\n}\r\nfunction isSVGElement(el) {\r\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\r\n}\r\nfunction getHref(doc, customHref) {\r\n    let a = cachedDocument.get(doc);\r\n    if (!a) {\r\n        a = doc.createElement('a');\r\n        cachedDocument.set(doc, a);\r\n    }\r\n    if (!customHref) {\r\n        customHref = '';\r\n    }\r\n    else if (customHref.startsWith('blob:') || customHref.startsWith('data:')) {\r\n        return customHref;\r\n    }\r\n    a.setAttribute('href', customHref);\r\n    return a.href;\r\n}\r\nfunction transformAttribute(doc, tagName, name, value) {\r\n    if (!value) {\r\n        return value;\r\n    }\r\n    if (name === 'src' ||\r\n        (name === 'href' && !(tagName === 'use' && value[0] === '#'))) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'xlink:href' && value[0] !== '#') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'background' &&\r\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'srcset') {\r\n        return getAbsoluteSrcsetString(doc, value);\r\n    }\r\n    else if (name === 'style') {\r\n        return absoluteToStylesheet(value, getHref(doc));\r\n    }\r\n    else if (tagName === 'object' && name === 'data') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    return value;\r\n}\r\nfunction ignoreAttribute(tagName, name, _value) {\r\n    return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\r\n}\r\nfunction _isBlockedElement(element, blockClass, blockSelector) {\r\n    try {\r\n        if (typeof blockClass === 'string') {\r\n            if (element.classList.contains(blockClass)) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (let eIndex = element.classList.length; eIndex--;) {\r\n                const className = element.classList[eIndex];\r\n                if (blockClass.test(className)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (blockSelector) {\r\n            return element.matches(blockSelector);\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction classMatchesRegex(node, regex, checkAncestors) {\r\n    if (!node)\r\n        return false;\r\n    if (node.nodeType !== node.ELEMENT_NODE) {\r\n        if (!checkAncestors)\r\n            return false;\r\n        return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n    }\r\n    for (let eIndex = node.classList.length; eIndex--;) {\r\n        const className = node.classList[eIndex];\r\n        if (regex.test(className)) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!checkAncestors)\r\n        return false;\r\n    return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n}\r\nfunction needMaskingText(node, maskTextClass, maskTextSelector, checkAncestors) {\r\n    try {\r\n        const el = node.nodeType === node.ELEMENT_NODE\r\n            ? node\r\n            : node.parentElement;\r\n        if (el === null)\r\n            return false;\r\n        if (typeof maskTextClass === 'string') {\r\n            if (checkAncestors) {\r\n                if (el.closest(`.${maskTextClass}`))\r\n                    return true;\r\n            }\r\n            else {\r\n                if (el.classList.contains(maskTextClass))\r\n                    return true;\r\n            }\r\n        }\r\n        else {\r\n            if (classMatchesRegex(el, maskTextClass, checkAncestors))\r\n                return true;\r\n        }\r\n        if (maskTextSelector) {\r\n            if (checkAncestors) {\r\n                if (el.closest(maskTextSelector))\r\n                    return true;\r\n            }\r\n            else {\r\n                if (el.matches(maskTextSelector))\r\n                    return true;\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\r\n    const win = iframeEl.contentWindow;\r\n    if (!win) {\r\n        return;\r\n    }\r\n    let fired = false;\r\n    let readyState;\r\n    try {\r\n        readyState = win.document.readyState;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (readyState !== 'complete') {\r\n        const timer = setTimeout(() => {\r\n            if (!fired) {\r\n                listener();\r\n                fired = true;\r\n            }\r\n        }, iframeLoadTimeout);\r\n        iframeEl.addEventListener('load', () => {\r\n            clearTimeout(timer);\r\n            fired = true;\r\n            listener();\r\n        });\r\n        return;\r\n    }\r\n    const blankUrl = 'about:blank';\r\n    if (win.location.href !== blankUrl ||\r\n        iframeEl.src === blankUrl ||\r\n        iframeEl.src === '') {\r\n        setTimeout(listener, 0);\r\n        return iframeEl.addEventListener('load', listener);\r\n    }\r\n    iframeEl.addEventListener('load', listener);\r\n}\r\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\r\n    let fired = false;\r\n    let styleSheetLoaded;\r\n    try {\r\n        styleSheetLoaded = link.sheet;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (styleSheetLoaded)\r\n        return;\r\n    const timer = setTimeout(() => {\r\n        if (!fired) {\r\n            listener();\r\n            fired = true;\r\n        }\r\n    }, styleSheetLoadTimeout);\r\n    link.addEventListener('load', () => {\r\n        clearTimeout(timer);\r\n        fired = true;\r\n        listener();\r\n    });\r\n}\r\nfunction serializeNode(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, needsMask, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, } = options;\r\n    const rootId = getRootId(doc, mirror);\r\n    switch (n.nodeType) {\r\n        case n.DOCUMENT_NODE:\r\n            if (n.compatMode !== 'CSS1Compat') {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                    compatMode: n.compatMode,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                };\r\n            }\r\n        case n.DOCUMENT_TYPE_NODE:\r\n            return {\r\n                type: NodeType.DocumentType,\r\n                name: n.name,\r\n                publicId: n.publicId,\r\n                systemId: n.systemId,\r\n                rootId,\r\n            };\r\n        case n.ELEMENT_NODE:\r\n            return serializeElementNode(n, {\r\n                doc,\r\n                blockClass,\r\n                blockSelector,\r\n                inlineStylesheet,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                dataURLOptions,\r\n                inlineImages,\r\n                recordCanvas,\r\n                keepIframeSrcFn,\r\n                newlyAddedElement,\r\n                rootId,\r\n            });\r\n        case n.TEXT_NODE:\r\n            return serializeTextNode(n, {\r\n                doc,\r\n                needsMask,\r\n                maskTextFn,\r\n                rootId,\r\n            });\r\n        case n.CDATA_SECTION_NODE:\r\n            return {\r\n                type: NodeType.CDATA,\r\n                textContent: '',\r\n                rootId,\r\n            };\r\n        case n.COMMENT_NODE:\r\n            return {\r\n                type: NodeType.Comment,\r\n                textContent: n.textContent || '',\r\n                rootId,\r\n            };\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getRootId(doc, mirror) {\r\n    if (!mirror.hasNode(doc))\r\n        return undefined;\r\n    const docId = mirror.getId(doc);\r\n    return docId === 1 ? undefined : docId;\r\n}\r\nfunction serializeTextNode(n, options) {\r\n    var _a;\r\n    const { needsMask, maskTextFn, rootId } = options;\r\n    const parentTagName = n.parentNode && n.parentNode.tagName;\r\n    let textContent = n.textContent;\r\n    const isStyle = parentTagName === 'STYLE' ? true : undefined;\r\n    const isScript = parentTagName === 'SCRIPT' ? true : undefined;\r\n    if (isStyle && textContent) {\r\n        try {\r\n            if (n.nextSibling || n.previousSibling) {\r\n            }\r\n            else if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {\r\n                textContent = stringifyStylesheet(n.parentNode.sheet);\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\r\n        }\r\n        textContent = absoluteToStylesheet(textContent, getHref(options.doc));\r\n    }\r\n    if (isScript) {\r\n        textContent = 'SCRIPT_PLACEHOLDER';\r\n    }\r\n    if (!isStyle && !isScript && textContent && needsMask) {\r\n        textContent = maskTextFn\r\n            ? maskTextFn(textContent, n.parentElement)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    return {\r\n        type: NodeType.Text,\r\n        textContent: textContent || '',\r\n        isStyle,\r\n        rootId,\r\n    };\r\n}\r\nfunction serializeElementNode(n, options) {\r\n    const { doc, blockClass, blockSelector, inlineStylesheet, maskInputOptions = {}, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, } = options;\r\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector);\r\n    const tagName = getValidTagName(n);\r\n    let attributes = {};\r\n    const len = n.attributes.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const attr = n.attributes[i];\r\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\r\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\r\n        }\r\n    }\r\n    if (tagName === 'link' && inlineStylesheet) {\r\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\r\n            return s.href === n.href;\r\n        });\r\n        let cssText = null;\r\n        if (stylesheet) {\r\n            cssText = stringifyStylesheet(stylesheet);\r\n        }\r\n        if (cssText) {\r\n            delete attributes.rel;\r\n            delete attributes.href;\r\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\r\n        }\r\n    }\r\n    if (tagName === 'style' &&\r\n        n.sheet &&\r\n        !(n.innerText || n.textContent || '').trim().length) {\r\n        const cssText = stringifyStylesheet(n.sheet);\r\n        if (cssText) {\r\n            attributes._cssText = absoluteToStylesheet(cssText, getHref(doc));\r\n        }\r\n    }\r\n    if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {\r\n        const value = n.value;\r\n        const checked = n.checked;\r\n        if (attributes.type !== 'radio' &&\r\n            attributes.type !== 'checkbox' &&\r\n            attributes.type !== 'submit' &&\r\n            attributes.type !== 'button' &&\r\n            value) {\r\n            attributes.value = maskInputValue({\r\n                element: n,\r\n                type: getInputType(n),\r\n                tagName,\r\n                value,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        else if (checked) {\r\n            attributes.checked = checked;\r\n        }\r\n    }\r\n    if (tagName === 'option') {\r\n        if (n.selected && !maskInputOptions['select']) {\r\n            attributes.selected = true;\r\n        }\r\n        else {\r\n            delete attributes.selected;\r\n        }\r\n    }\r\n    if (tagName === 'canvas' && recordCanvas) {\r\n        if (n.__context === '2d') {\r\n            if (!is2DCanvasBlank(n)) {\r\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n        }\r\n        else if (!('__context' in n)) {\r\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            const blankCanvas = document.createElement('canvas');\r\n            blankCanvas.width = n.width;\r\n            blankCanvas.height = n.height;\r\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            if (canvasDataURL !== blankCanvasDataURL) {\r\n                attributes.rr_dataURL = canvasDataURL;\r\n            }\r\n        }\r\n    }\r\n    if (tagName === 'img' && inlineImages) {\r\n        if (!canvasService) {\r\n            canvasService = doc.createElement('canvas');\r\n            canvasCtx = canvasService.getContext('2d');\r\n        }\r\n        const image = n;\r\n        const oldValue = image.crossOrigin;\r\n        image.crossOrigin = 'anonymous';\r\n        const recordInlineImage = () => {\r\n            image.removeEventListener('load', recordInlineImage);\r\n            try {\r\n                canvasService.width = image.naturalWidth;\r\n                canvasService.height = image.naturalHeight;\r\n                canvasCtx.drawImage(image, 0, 0);\r\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n            catch (err) {\r\n                console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\r\n            }\r\n            oldValue\r\n                ? (attributes.crossOrigin = oldValue)\r\n                : image.removeAttribute('crossorigin');\r\n        };\r\n        if (image.complete && image.naturalWidth !== 0)\r\n            recordInlineImage();\r\n        else\r\n            image.addEventListener('load', recordInlineImage);\r\n    }\r\n    if (tagName === 'audio' || tagName === 'video') {\r\n        const mediaAttributes = attributes;\r\n        mediaAttributes.rr_mediaState = n.paused\r\n            ? 'paused'\r\n            : 'played';\r\n        mediaAttributes.rr_mediaCurrentTime = n.currentTime;\r\n        mediaAttributes.rr_mediaPlaybackRate = n.playbackRate;\r\n        mediaAttributes.rr_mediaMuted = n.muted;\r\n        mediaAttributes.rr_mediaLoop = n.loop;\r\n        mediaAttributes.rr_mediaVolume = n.volume;\r\n    }\r\n    if (!newlyAddedElement) {\r\n        if (n.scrollLeft) {\r\n            attributes.rr_scrollLeft = n.scrollLeft;\r\n        }\r\n        if (n.scrollTop) {\r\n            attributes.rr_scrollTop = n.scrollTop;\r\n        }\r\n    }\r\n    if (needBlock) {\r\n        const { width, height } = n.getBoundingClientRect();\r\n        attributes = {\r\n            class: attributes.class,\r\n            rr_width: `${width}px`,\r\n            rr_height: `${height}px`,\r\n        };\r\n    }\r\n    if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\r\n        if (!n.contentDocument) {\r\n            attributes.rr_src = attributes.src;\r\n        }\r\n        delete attributes.src;\r\n    }\r\n    let isCustomElement;\r\n    try {\r\n        if (customElements.get(tagName))\r\n            isCustomElement = true;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return {\r\n        type: NodeType.Element,\r\n        tagName,\r\n        attributes,\r\n        childNodes: [],\r\n        isSVG: isSVGElement(n) || undefined,\r\n        needBlock,\r\n        rootId,\r\n        isCustom: isCustomElement,\r\n    };\r\n}\r\nfunction lowerIfExists(maybeAttr) {\r\n    if (maybeAttr === undefined || maybeAttr === null) {\r\n        return '';\r\n    }\r\n    else {\r\n        return maybeAttr.toLowerCase();\r\n    }\r\n}\r\nfunction slimDOMExcluded(sn, slimDOMOptions) {\r\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\r\n        return true;\r\n    }\r\n    else if (sn.type === NodeType.Element) {\r\n        if (slimDOMOptions.script &&\r\n            (sn.tagName === 'script' ||\r\n                (sn.tagName === 'link' &&\r\n                    (sn.attributes.rel === 'preload' ||\r\n                        sn.attributes.rel === 'modulepreload') &&\r\n                    sn.attributes.as === 'script') ||\r\n                (sn.tagName === 'link' &&\r\n                    sn.attributes.rel === 'prefetch' &&\r\n                    typeof sn.attributes.href === 'string' &&\r\n                    extractFileExtension(sn.attributes.href) === 'js'))) {\r\n            return true;\r\n        }\r\n        else if (slimDOMOptions.headFavicon &&\r\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\r\n                (sn.tagName === 'meta' &&\r\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\r\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\r\n            return true;\r\n        }\r\n        else if (sn.tagName === 'meta') {\r\n            if (slimDOMOptions.headMetaDescKeywords &&\r\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaSocial &&\r\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\r\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\r\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaRobots &&\r\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\r\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\r\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaHttpEquiv &&\r\n                sn.attributes['http-equiv'] !== undefined) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaAuthorship &&\r\n                (lowerIfExists(sn.attributes.name) === 'author' ||\r\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\r\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\r\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\r\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\r\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\r\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaVerification &&\r\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\r\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction serializeNodeWithId(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, maskTextClass, maskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = () => false, newlyAddedElement = false, } = options;\r\n    let { needsMask } = options;\r\n    let { preserveWhiteSpace = true } = options;\r\n    if (!needsMask &&\r\n        n.childNodes) {\r\n        const checkAncestors = needsMask === undefined;\r\n        needsMask = needMaskingText(n, maskTextClass, maskTextSelector, checkAncestors);\r\n    }\r\n    const _serializedNode = serializeNode(n, {\r\n        doc,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        needsMask,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement,\r\n    });\r\n    if (!_serializedNode) {\r\n        console.warn(n, 'not serialized');\r\n        return null;\r\n    }\r\n    let id;\r\n    if (mirror.hasNode(n)) {\r\n        id = mirror.getId(n);\r\n    }\r\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\r\n        (!preserveWhiteSpace &&\r\n            _serializedNode.type === NodeType.Text &&\r\n            !_serializedNode.isStyle &&\r\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\r\n        id = IGNORED_NODE;\r\n    }\r\n    else {\r\n        id = genId();\r\n    }\r\n    const serializedNode = Object.assign(_serializedNode, { id });\r\n    mirror.add(n, serializedNode);\r\n    if (id === IGNORED_NODE) {\r\n        return null;\r\n    }\r\n    if (onSerialize) {\r\n        onSerialize(n);\r\n    }\r\n    let recordChild = !skipChild;\r\n    if (serializedNode.type === NodeType.Element) {\r\n        recordChild = recordChild && !serializedNode.needBlock;\r\n        delete serializedNode.needBlock;\r\n        const shadowRoot = n.shadowRoot;\r\n        if (shadowRoot && isNativeShadowDom(shadowRoot))\r\n            serializedNode.isShadowHost = true;\r\n    }\r\n    if ((serializedNode.type === NodeType.Document ||\r\n        serializedNode.type === NodeType.Element) &&\r\n        recordChild) {\r\n        if (slimDOMOptions.headWhitespace &&\r\n            serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'head') {\r\n            preserveWhiteSpace = false;\r\n        }\r\n        const bypassOptions = {\r\n            doc,\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            needsMask,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            skipChild,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            slimDOMOptions,\r\n            dataURLOptions,\r\n            inlineImages,\r\n            recordCanvas,\r\n            preserveWhiteSpace,\r\n            onSerialize,\r\n            onIframeLoad,\r\n            iframeLoadTimeout,\r\n            onStylesheetLoad,\r\n            stylesheetLoadTimeout,\r\n            keepIframeSrcFn,\r\n        };\r\n        if (serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'textarea' &&\r\n            serializedNode.attributes.value !== undefined) ;\r\n        else {\r\n            for (const childN of Array.from(n.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n        if (isElement(n) && n.shadowRoot) {\r\n            for (const childN of Array.from(n.shadowRoot.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    isNativeShadowDom(n.shadowRoot) &&\r\n                        (serializedChildNode.isShadow = true);\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (n.parentNode &&\r\n        isShadowRoot(n.parentNode) &&\r\n        isNativeShadowDom(n.parentNode)) {\r\n        serializedNode.isShadow = true;\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'iframe') {\r\n        onceIframeLoaded(n, () => {\r\n            const iframeDoc = n.contentDocument;\r\n            if (iframeDoc && onIframeLoad) {\r\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\r\n                    doc: iframeDoc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    needsMask,\r\n                    maskTextClass,\r\n                    maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedIframeNode) {\r\n                    onIframeLoad(n, serializedIframeNode);\r\n                }\r\n            }\r\n        }, iframeLoadTimeout);\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'link' &&\r\n        typeof serializedNode.attributes.rel === 'string' &&\r\n        (serializedNode.attributes.rel === 'stylesheet' ||\r\n            (serializedNode.attributes.rel === 'preload' &&\r\n                typeof serializedNode.attributes.href === 'string' &&\r\n                extractFileExtension(serializedNode.attributes.href) === 'css'))) {\r\n        onceStylesheetLoaded(n, () => {\r\n            if (onStylesheetLoad) {\r\n                const serializedLinkNode = serializeNodeWithId(n, {\r\n                    doc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    needsMask,\r\n                    maskTextClass,\r\n                    maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedLinkNode) {\r\n                    onStylesheetLoad(n, serializedLinkNode);\r\n                }\r\n            }\r\n        }, stylesheetLoadTimeout);\r\n    }\r\n    return serializedNode;\r\n}\r\nfunction snapshot(n, options) {\r\n    const { mirror = new Mirror(), blockClass = 'rr-block', blockSelector = null, maskTextClass = 'rr-mask', maskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false, } = options || {};\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n            password: true,\r\n        }\r\n        : maskAllInputs === false\r\n            ? {\r\n                password: true,\r\n            }\r\n            : maskAllInputs;\r\n    const slimDOMOptions = slimDOM === true || slimDOM === 'all'\r\n        ?\r\n            {\r\n                script: true,\r\n                comment: true,\r\n                headFavicon: true,\r\n                headWhitespace: true,\r\n                headMetaDescKeywords: slimDOM === 'all',\r\n                headMetaSocial: true,\r\n                headMetaRobots: true,\r\n                headMetaHttpEquiv: true,\r\n                headMetaAuthorship: true,\r\n                headMetaVerification: true,\r\n            }\r\n        : slimDOM === false\r\n            ? {}\r\n            : slimDOM;\r\n    return serializeNodeWithId(n, {\r\n        doc: n,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        maskTextClass,\r\n        maskTextSelector,\r\n        skipChild: false,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        slimDOMOptions,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        preserveWhiteSpace,\r\n        onSerialize,\r\n        onIframeLoad,\r\n        iframeLoadTimeout,\r\n        onStylesheetLoad,\r\n        stylesheetLoadTimeout,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement: false,\r\n    });\r\n}\r\nfunction visitSnapshot(node, onVisit) {\r\n    function walk(current) {\r\n        onVisit(current);\r\n        if (current.type === NodeType.Document ||\r\n            current.type === NodeType.Element) {\r\n            current.childNodes.forEach(walk);\r\n        }\r\n    }\r\n    walk(node);\r\n}\r\nfunction cleanupSnapshot() {\r\n    _id = 1;\r\n}\n\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\r\nfunction parse(css, options = {}) {\r\n    let lineno = 1;\r\n    let column = 1;\r\n    function updatePosition(str) {\r\n        const lines = str.match(/\\n/g);\r\n        if (lines) {\r\n            lineno += lines.length;\r\n        }\r\n        const i = str.lastIndexOf('\\n');\r\n        column = i === -1 ? column + str.length : str.length - i;\r\n    }\r\n    function position() {\r\n        const start = { line: lineno, column };\r\n        return (node) => {\r\n            node.position = new Position(start);\r\n            whitespace();\r\n            return node;\r\n        };\r\n    }\r\n    class Position {\r\n        constructor(start) {\r\n            this.start = start;\r\n            this.end = { line: lineno, column };\r\n            this.source = options.source;\r\n        }\r\n    }\r\n    Position.prototype.content = css;\r\n    const errorsList = [];\r\n    function error(msg) {\r\n        const err = new Error(`${options.source || ''}:${lineno}:${column}: ${msg}`);\r\n        err.reason = msg;\r\n        err.filename = options.source;\r\n        err.line = lineno;\r\n        err.column = column;\r\n        err.source = css;\r\n        if (options.silent) {\r\n            errorsList.push(err);\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n    function stylesheet() {\r\n        const rulesList = rules();\r\n        return {\r\n            type: 'stylesheet',\r\n            stylesheet: {\r\n                source: options.source,\r\n                rules: rulesList,\r\n                parsingErrors: errorsList,\r\n            },\r\n        };\r\n    }\r\n    function open() {\r\n        return match(/^{\\s*/);\r\n    }\r\n    function close() {\r\n        return match(/^}/);\r\n    }\r\n    function rules() {\r\n        let node;\r\n        const rules = [];\r\n        whitespace();\r\n        comments(rules);\r\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\r\n            if (node) {\r\n                rules.push(node);\r\n                comments(rules);\r\n            }\r\n        }\r\n        return rules;\r\n    }\r\n    function match(re) {\r\n        const m = re.exec(css);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const str = m[0];\r\n        updatePosition(str);\r\n        css = css.slice(str.length);\r\n        return m;\r\n    }\r\n    function whitespace() {\r\n        match(/^\\s*/);\r\n    }\r\n    function comments(rules = []) {\r\n        let c;\r\n        while ((c = comment())) {\r\n            if (c) {\r\n                rules.push(c);\r\n            }\r\n            c = comment();\r\n        }\r\n        return rules;\r\n    }\r\n    function comment() {\r\n        const pos = position();\r\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\r\n            return;\r\n        }\r\n        let i = 2;\r\n        while ('' !== css.charAt(i) &&\r\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\r\n            ++i;\r\n        }\r\n        i += 2;\r\n        if ('' === css.charAt(i - 1)) {\r\n            return error('End of comment missing');\r\n        }\r\n        const str = css.slice(2, i - 2);\r\n        column += 2;\r\n        updatePosition(str);\r\n        css = css.slice(i);\r\n        column += 2;\r\n        return pos({\r\n            type: 'comment',\r\n            comment: str,\r\n        });\r\n    }\r\n    function selector() {\r\n        whitespace();\r\n        while (css[0] == '}') {\r\n            error('extra closing bracket');\r\n            css = css.slice(1);\r\n            whitespace();\r\n        }\r\n        const m = match(/^(((?<!\\\\)\"(?:\\\\\"|[^\"])*\"|(?<!\\\\)'(?:\\\\'|[^'])*'|[^{])+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const cleanedInput = m[0]\r\n            .trim()\r\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\r\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\r\n            return m.replace(/,/g, '\\u200C');\r\n        });\r\n        return customSplit(cleanedInput).map((s) => s.replace(/\\u200C/g, ',').trim());\r\n    }\r\n    function customSplit(input) {\r\n        const result = [];\r\n        let currentSegment = '';\r\n        let depthParentheses = 0;\r\n        let depthBrackets = 0;\r\n        let currentStringChar = null;\r\n        for (const char of input) {\r\n            const hasStringEscape = currentSegment.endsWith('\\\\');\r\n            if (currentStringChar) {\r\n                if (currentStringChar === char && !hasStringEscape) {\r\n                    currentStringChar = null;\r\n                }\r\n            }\r\n            else if (char === '(') {\r\n                depthParentheses++;\r\n            }\r\n            else if (char === ')') {\r\n                depthParentheses--;\r\n            }\r\n            else if (char === '[') {\r\n                depthBrackets++;\r\n            }\r\n            else if (char === ']') {\r\n                depthBrackets--;\r\n            }\r\n            else if ('\\'\"'.includes(char)) {\r\n                currentStringChar = char;\r\n            }\r\n            if (char === ',' && depthParentheses === 0 && depthBrackets === 0) {\r\n                result.push(currentSegment);\r\n                currentSegment = '';\r\n            }\r\n            else {\r\n                currentSegment += char;\r\n            }\r\n        }\r\n        if (currentSegment) {\r\n            result.push(currentSegment);\r\n        }\r\n        return result;\r\n    }\r\n    function declaration() {\r\n        const pos = position();\r\n        const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\r\n        if (!propMatch) {\r\n            return;\r\n        }\r\n        const prop = trim(propMatch[0]);\r\n        if (!match(/^:\\s*/)) {\r\n            return error(`property missing ':'`);\r\n        }\r\n        const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\r\n        const ret = pos({\r\n            type: 'declaration',\r\n            property: prop.replace(commentre, ''),\r\n            value: val ? trim(val[0]).replace(commentre, '') : '',\r\n        });\r\n        match(/^[;\\s]*/);\r\n        return ret;\r\n    }\r\n    function declarations() {\r\n        const decls = [];\r\n        if (!open()) {\r\n            return error(`missing '{'`);\r\n        }\r\n        comments(decls);\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            if (decl !== false) {\r\n                decls.push(decl);\r\n                comments(decls);\r\n            }\r\n            decl = declaration();\r\n        }\r\n        if (!close()) {\r\n            return error(`missing '}'`);\r\n        }\r\n        return decls;\r\n    }\r\n    function keyframe() {\r\n        let m;\r\n        const vals = [];\r\n        const pos = position();\r\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\r\n            vals.push(m[1]);\r\n            match(/^,\\s*/);\r\n        }\r\n        if (!vals.length) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'keyframe',\r\n            values: vals,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    function atkeyframes() {\r\n        const pos = position();\r\n        let m = match(/^@([-\\w]+)?keyframes\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = m[1];\r\n        m = match(/^([-\\w]+)\\s*/);\r\n        if (!m) {\r\n            return error('@keyframes missing name');\r\n        }\r\n        const name = m[1];\r\n        if (!open()) {\r\n            return error(`@keyframes missing '{'`);\r\n        }\r\n        let frame;\r\n        let frames = comments();\r\n        while ((frame = keyframe())) {\r\n            frames.push(frame);\r\n            frames = frames.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@keyframes missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'keyframes',\r\n            name,\r\n            vendor,\r\n            keyframes: frames,\r\n        });\r\n    }\r\n    function atsupports() {\r\n        const pos = position();\r\n        const m = match(/^@supports *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const supports = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@supports missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@supports missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'supports',\r\n            supports,\r\n            rules: style,\r\n        });\r\n    }\r\n    function athost() {\r\n        const pos = position();\r\n        const m = match(/^@host\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@host missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@host missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'host',\r\n            rules: style,\r\n        });\r\n    }\r\n    function atmedia() {\r\n        const pos = position();\r\n        const m = match(/^@media *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const media = trim(m[1]);\r\n        if (!open()) {\r\n            return error(`@media missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@media missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'media',\r\n            media,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atcustommedia() {\r\n        const pos = position();\r\n        const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        return pos({\r\n            type: 'custom-media',\r\n            name: trim(m[1]),\r\n            media: trim(m[2]),\r\n        });\r\n    }\r\n    function atpage() {\r\n        const pos = position();\r\n        const m = match(/^@page */);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const sel = selector() || [];\r\n        if (!open()) {\r\n            return error(`@page missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@page missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'page',\r\n            selectors: sel,\r\n            declarations: decls,\r\n        });\r\n    }\r\n    function atdocument() {\r\n        const pos = position();\r\n        const m = match(/^@([-\\w]+)?document *([^{]+)/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        const vendor = trim(m[1]);\r\n        const doc = trim(m[2]);\r\n        if (!open()) {\r\n            return error(`@document missing '{'`);\r\n        }\r\n        const style = comments().concat(rules());\r\n        if (!close()) {\r\n            return error(`@document missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'document',\r\n            document: doc,\r\n            vendor,\r\n            rules: style,\r\n        });\r\n    }\r\n    function atfontface() {\r\n        const pos = position();\r\n        const m = match(/^@font-face\\s*/);\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (!open()) {\r\n            return error(`@font-face missing '{'`);\r\n        }\r\n        let decls = comments();\r\n        let decl;\r\n        while ((decl = declaration())) {\r\n            decls.push(decl);\r\n            decls = decls.concat(comments());\r\n        }\r\n        if (!close()) {\r\n            return error(`@font-face missing '}'`);\r\n        }\r\n        return pos({\r\n            type: 'font-face',\r\n            declarations: decls,\r\n        });\r\n    }\r\n    const atimport = _compileAtrule('import');\r\n    const atcharset = _compileAtrule('charset');\r\n    const atnamespace = _compileAtrule('namespace');\r\n    function _compileAtrule(name) {\r\n        const re = new RegExp('^@' +\r\n            name +\r\n            '\\\\s*((?:' +\r\n            [\r\n                '(?<!\\\\\\\\)\"(?:\\\\\\\\\"|[^\"])*\"',\r\n                \"(?<!\\\\\\\\)'(?:\\\\\\\\'|[^'])*'\",\r\n                '[^;]',\r\n            ].join('|') +\r\n            ')+);');\r\n        return () => {\r\n            const pos = position();\r\n            const m = match(re);\r\n            if (!m) {\r\n                return;\r\n            }\r\n            const ret = { type: name };\r\n            ret[name] = m[1].trim();\r\n            return pos(ret);\r\n        };\r\n    }\r\n    function atrule() {\r\n        if (css[0] !== '@') {\r\n            return;\r\n        }\r\n        return (atkeyframes() ||\r\n            atmedia() ||\r\n            atcustommedia() ||\r\n            atsupports() ||\r\n            atimport() ||\r\n            atcharset() ||\r\n            atnamespace() ||\r\n            atdocument() ||\r\n            atpage() ||\r\n            athost() ||\r\n            atfontface());\r\n    }\r\n    function rule() {\r\n        const pos = position();\r\n        const sel = selector();\r\n        if (!sel) {\r\n            return error('selector missing');\r\n        }\r\n        comments();\r\n        return pos({\r\n            type: 'rule',\r\n            selectors: sel,\r\n            declarations: declarations(),\r\n        });\r\n    }\r\n    return addParent(stylesheet());\r\n}\r\nfunction trim(str) {\r\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\r\n}\r\nfunction addParent(obj, parent) {\r\n    const isNode = obj && typeof obj.type === 'string';\r\n    const childParent = isNode ? obj : parent;\r\n    for (const k of Object.keys(obj)) {\r\n        const value = obj[k];\r\n        if (Array.isArray(value)) {\r\n            value.forEach((v) => {\r\n                addParent(v, childParent);\r\n            });\r\n        }\r\n        else if (value && typeof value === 'object') {\r\n            addParent(value, childParent);\r\n        }\r\n    }\r\n    if (isNode) {\r\n        Object.defineProperty(obj, 'parent', {\r\n            configurable: true,\r\n            writable: true,\r\n            enumerable: false,\r\n            value: parent || null,\r\n        });\r\n    }\r\n    return obj;\r\n}\n\nconst tagMap = {\r\n    script: 'noscript',\r\n    altglyph: 'altGlyph',\r\n    altglyphdef: 'altGlyphDef',\r\n    altglyphitem: 'altGlyphItem',\r\n    animatecolor: 'animateColor',\r\n    animatemotion: 'animateMotion',\r\n    animatetransform: 'animateTransform',\r\n    clippath: 'clipPath',\r\n    feblend: 'feBlend',\r\n    fecolormatrix: 'feColorMatrix',\r\n    fecomponenttransfer: 'feComponentTransfer',\r\n    fecomposite: 'feComposite',\r\n    feconvolvematrix: 'feConvolveMatrix',\r\n    fediffuselighting: 'feDiffuseLighting',\r\n    fedisplacementmap: 'feDisplacementMap',\r\n    fedistantlight: 'feDistantLight',\r\n    fedropshadow: 'feDropShadow',\r\n    feflood: 'feFlood',\r\n    fefunca: 'feFuncA',\r\n    fefuncb: 'feFuncB',\r\n    fefuncg: 'feFuncG',\r\n    fefuncr: 'feFuncR',\r\n    fegaussianblur: 'feGaussianBlur',\r\n    feimage: 'feImage',\r\n    femerge: 'feMerge',\r\n    femergenode: 'feMergeNode',\r\n    femorphology: 'feMorphology',\r\n    feoffset: 'feOffset',\r\n    fepointlight: 'fePointLight',\r\n    fespecularlighting: 'feSpecularLighting',\r\n    fespotlight: 'feSpotLight',\r\n    fetile: 'feTile',\r\n    feturbulence: 'feTurbulence',\r\n    foreignobject: 'foreignObject',\r\n    glyphref: 'glyphRef',\r\n    lineargradient: 'linearGradient',\r\n    radialgradient: 'radialGradient',\r\n};\r\nfunction getTagName(n) {\r\n    let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\r\n    if (tagName === 'link' && n.attributes._cssText) {\r\n        tagName = 'style';\r\n    }\r\n    return tagName;\r\n}\r\nfunction escapeRegExp(str) {\r\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\nconst MEDIA_SELECTOR = /(max|min)-device-(width|height)/;\r\nconst MEDIA_SELECTOR_GLOBAL = new RegExp(MEDIA_SELECTOR.source, 'g');\r\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\r\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\r\nfunction adaptCssForReplay(cssText, cache) {\r\n    const cachedStyle = cache === null || cache === void 0 ? void 0 : cache.stylesWithHoverClass.get(cssText);\r\n    if (cachedStyle)\r\n        return cachedStyle;\r\n    const ast = parse(cssText, {\r\n        silent: true,\r\n    });\r\n    if (!ast.stylesheet) {\r\n        return cssText;\r\n    }\r\n    const selectors = [];\r\n    const medias = [];\r\n    function getSelectors(rule) {\r\n        if ('selectors' in rule && rule.selectors) {\r\n            rule.selectors.forEach((selector) => {\r\n                if (HOVER_SELECTOR.test(selector)) {\r\n                    selectors.push(selector);\r\n                }\r\n            });\r\n        }\r\n        if ('media' in rule && rule.media && MEDIA_SELECTOR.test(rule.media)) {\r\n            medias.push(rule.media);\r\n        }\r\n        if ('rules' in rule && rule.rules) {\r\n            rule.rules.forEach(getSelectors);\r\n        }\r\n    }\r\n    getSelectors(ast.stylesheet);\r\n    let result = cssText;\r\n    if (selectors.length > 0) {\r\n        const selectorMatcher = new RegExp(selectors\r\n            .filter((selector, index) => selectors.indexOf(selector) === index)\r\n            .sort((a, b) => b.length - a.length)\r\n            .map((selector) => {\r\n            return escapeRegExp(selector);\r\n        })\r\n            .join('|'), 'g');\r\n        result = result.replace(selectorMatcher, (selector) => {\r\n            const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\r\n            return `${selector}, ${newSelector}`;\r\n        });\r\n    }\r\n    if (medias.length > 0) {\r\n        const mediaMatcher = new RegExp(medias\r\n            .filter((media, index) => medias.indexOf(media) === index)\r\n            .sort((a, b) => b.length - a.length)\r\n            .map((media) => {\r\n            return escapeRegExp(media);\r\n        })\r\n            .join('|'), 'g');\r\n        result = result.replace(mediaMatcher, (media) => {\r\n            return media.replace(MEDIA_SELECTOR_GLOBAL, '$1-$2');\r\n        });\r\n    }\r\n    cache === null || cache === void 0 ? void 0 : cache.stylesWithHoverClass.set(cssText, result);\r\n    return result;\r\n}\r\nfunction createCache() {\r\n    const stylesWithHoverClass = new Map();\r\n    return {\r\n        stylesWithHoverClass,\r\n    };\r\n}\r\nfunction buildNode(n, options) {\r\n    var _a;\r\n    const { doc, hackCss, cache } = options;\r\n    switch (n.type) {\r\n        case NodeType.Document:\r\n            return doc.implementation.createDocument(null, '', null);\r\n        case NodeType.DocumentType:\r\n            return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);\r\n        case NodeType.Element: {\r\n            const tagName = getTagName(n);\r\n            let node;\r\n            if (n.isSVG) {\r\n                node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\r\n            }\r\n            else {\r\n                if (n.isCustom &&\r\n                    ((_a = doc.defaultView) === null || _a === void 0 ? void 0 : _a.customElements) &&\r\n                    !doc.defaultView.customElements.get(n.tagName))\r\n                    doc.defaultView.customElements.define(n.tagName, class extends doc.defaultView.HTMLElement {\r\n                    });\r\n                node = doc.createElement(tagName);\r\n            }\r\n            const specialAttributes = {};\r\n            for (const name in n.attributes) {\r\n                if (!Object.prototype.hasOwnProperty.call(n.attributes, name)) {\r\n                    continue;\r\n                }\r\n                let value = n.attributes[name];\r\n                if (tagName === 'option' &&\r\n                    name === 'selected' &&\r\n                    value === false) {\r\n                    continue;\r\n                }\r\n                if (value === null) {\r\n                    continue;\r\n                }\r\n                if (value === true)\r\n                    value = '';\r\n                if (name.startsWith('rr_')) {\r\n                    specialAttributes[name] = value;\r\n                    continue;\r\n                }\r\n                const isTextarea = tagName === 'textarea' && name === 'value';\r\n                const isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\r\n                if (isRemoteOrDynamicCss && hackCss && typeof value === 'string') {\r\n                    value = adaptCssForReplay(value, cache);\r\n                }\r\n                if ((isTextarea || isRemoteOrDynamicCss) && typeof value === 'string') {\r\n                    node.appendChild(doc.createTextNode(value));\r\n                    n.childNodes = [];\r\n                    continue;\r\n                }\r\n                try {\r\n                    if (n.isSVG && name === 'xlink:href') {\r\n                        node.setAttributeNS('http://www.w3.org/1999/xlink', name, value.toString());\r\n                    }\r\n                    else if (name === 'onload' ||\r\n                        name === 'onclick' ||\r\n                        name.substring(0, 7) === 'onmouse') {\r\n                        node.setAttribute('_' + name, value.toString());\r\n                    }\r\n                    else if (tagName === 'meta' &&\r\n                        n.attributes['http-equiv'] === 'Content-Security-Policy' &&\r\n                        name === 'content') {\r\n                        node.setAttribute('csp-content', value.toString());\r\n                        continue;\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        (n.attributes.rel === 'preload' ||\r\n                            n.attributes.rel === 'modulepreload') &&\r\n                        n.attributes.as === 'script') {\r\n                    }\r\n                    else if (tagName === 'link' &&\r\n                        n.attributes.rel === 'prefetch' &&\r\n                        typeof n.attributes.href === 'string' &&\r\n                        n.attributes.href.endsWith('.js')) {\r\n                    }\r\n                    else if (tagName === 'img' &&\r\n                        n.attributes.srcset &&\r\n                        n.attributes.rr_dataURL) {\r\n                        node.setAttribute('rrweb-original-srcset', n.attributes.srcset);\r\n                    }\r\n                    else {\r\n                        node.setAttribute(name, value.toString());\r\n                    }\r\n                }\r\n                catch (error) {\r\n                }\r\n            }\r\n            for (const name in specialAttributes) {\r\n                const value = specialAttributes[name];\r\n                if (tagName === 'canvas' && name === 'rr_dataURL') {\r\n                    const image = document.createElement('img');\r\n                    image.onload = () => {\r\n                        const ctx = node.getContext('2d');\r\n                        if (ctx) {\r\n                            ctx.drawImage(image, 0, 0, image.width, image.height);\r\n                        }\r\n                    };\r\n                    image.src = value.toString();\r\n                    if (node.RRNodeType)\r\n                        node.rr_dataURL = value.toString();\r\n                }\r\n                else if (tagName === 'img' && name === 'rr_dataURL') {\r\n                    const image = node;\r\n                    if (!image.currentSrc.startsWith('data:')) {\r\n                        image.setAttribute('rrweb-original-src', n.attributes.src);\r\n                        image.src = value.toString();\r\n                    }\r\n                }\r\n                if (name === 'rr_width') {\r\n                    node.style.width = value.toString();\r\n                }\r\n                else if (name === 'rr_height') {\r\n                    node.style.height = value.toString();\r\n                }\r\n                else if (name === 'rr_mediaCurrentTime' &&\r\n                    typeof value === 'number') {\r\n                    node.currentTime = value;\r\n                }\r\n                else if (name === 'rr_mediaState') {\r\n                    switch (value) {\r\n                        case 'played':\r\n                            node\r\n                                .play()\r\n                                .catch((e) => console.warn('media playback error', e));\r\n                            break;\r\n                        case 'paused':\r\n                            node.pause();\r\n                            break;\r\n                    }\r\n                }\r\n                else if (name === 'rr_mediaPlaybackRate' &&\r\n                    typeof value === 'number') {\r\n                    node.playbackRate = value;\r\n                }\r\n                else if (name === 'rr_mediaMuted' && typeof value === 'boolean') {\r\n                    node.muted = value;\r\n                }\r\n                else if (name === 'rr_mediaLoop' && typeof value === 'boolean') {\r\n                    node.loop = value;\r\n                }\r\n                else if (name === 'rr_mediaVolume' && typeof value === 'number') {\r\n                    node.volume = value;\r\n                }\r\n            }\r\n            if (n.isShadowHost) {\r\n                if (!node.shadowRoot) {\r\n                    node.attachShadow({ mode: 'open' });\r\n                }\r\n                else {\r\n                    while (node.shadowRoot.firstChild) {\r\n                        node.shadowRoot.removeChild(node.shadowRoot.firstChild);\r\n                    }\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n        case NodeType.Text:\r\n            return doc.createTextNode(n.isStyle && hackCss\r\n                ? adaptCssForReplay(n.textContent, cache)\r\n                : n.textContent);\r\n        case NodeType.CDATA:\r\n            return doc.createCDATASection(n.textContent);\r\n        case NodeType.Comment:\r\n            return doc.createComment(n.textContent);\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction buildNodeWithSN(n, options) {\r\n    const { doc, mirror, skipChild = false, hackCss = true, afterAppend, cache, } = options;\r\n    if (mirror.has(n.id)) {\r\n        const nodeInMirror = mirror.getNode(n.id);\r\n        const meta = mirror.getMeta(nodeInMirror);\r\n        if (isNodeMetaEqual(meta, n))\r\n            return mirror.getNode(n.id);\r\n    }\r\n    let node = buildNode(n, { doc, hackCss, cache });\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    if (n.rootId && mirror.getNode(n.rootId) !== doc) {\r\n        mirror.replace(n.rootId, doc);\r\n    }\r\n    if (n.type === NodeType.Document) {\r\n        doc.close();\r\n        doc.open();\r\n        if (n.compatMode === 'BackCompat' &&\r\n            n.childNodes &&\r\n            n.childNodes[0].type !== NodeType.DocumentType) {\r\n            if (n.childNodes[0].type === NodeType.Element &&\r\n                'xmlns' in n.childNodes[0].attributes &&\r\n                n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml') {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">');\r\n            }\r\n            else {\r\n                doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">');\r\n            }\r\n        }\r\n        node = doc;\r\n    }\r\n    mirror.add(node, n);\r\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\r\n        !skipChild) {\r\n        for (const childN of n.childNodes) {\r\n            const childNode = buildNodeWithSN(childN, {\r\n                doc,\r\n                mirror,\r\n                skipChild: false,\r\n                hackCss,\r\n                afterAppend,\r\n                cache,\r\n            });\r\n            if (!childNode) {\r\n                console.warn('Failed to rebuild', childN);\r\n                continue;\r\n            }\r\n            if (childN.isShadow && isElement(node) && node.shadowRoot) {\r\n                node.shadowRoot.appendChild(childNode);\r\n            }\r\n            else if (n.type === NodeType.Document &&\r\n                childN.type == NodeType.Element) {\r\n                const htmlElement = childNode;\r\n                let body = null;\r\n                htmlElement.childNodes.forEach((child) => {\r\n                    if (child.nodeName === 'BODY')\r\n                        body = child;\r\n                });\r\n                if (body) {\r\n                    htmlElement.removeChild(body);\r\n                    node.appendChild(childNode);\r\n                    htmlElement.appendChild(body);\r\n                }\r\n                else {\r\n                    node.appendChild(childNode);\r\n                }\r\n            }\r\n            else {\r\n                node.appendChild(childNode);\r\n            }\r\n            if (afterAppend) {\r\n                afterAppend(childNode, childN.id);\r\n            }\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction visit(mirror, onVisit) {\r\n    function walk(node) {\r\n        onVisit(node);\r\n    }\r\n    for (const id of mirror.getIds()) {\r\n        if (mirror.has(id)) {\r\n            walk(mirror.getNode(id));\r\n        }\r\n    }\r\n}\r\nfunction handleScroll(node, mirror) {\r\n    const n = mirror.getMeta(node);\r\n    if ((n === null || n === void 0 ? void 0 : n.type) !== NodeType.Element) {\r\n        return;\r\n    }\r\n    const el = node;\r\n    for (const name in n.attributes) {\r\n        if (!(Object.prototype.hasOwnProperty.call(n.attributes, name) &&\r\n            name.startsWith('rr_'))) {\r\n            continue;\r\n        }\r\n        const value = n.attributes[name];\r\n        if (name === 'rr_scrollLeft') {\r\n            el.scrollLeft = value;\r\n        }\r\n        if (name === 'rr_scrollTop') {\r\n            el.scrollTop = value;\r\n        }\r\n    }\r\n}\r\nfunction rebuild(n, options) {\r\n    const { doc, onVisit, hackCss = true, afterAppend, cache, mirror = new Mirror(), } = options;\r\n    const node = buildNodeWithSN(n, {\r\n        doc,\r\n        mirror,\r\n        skipChild: false,\r\n        hackCss,\r\n        afterAppend,\r\n        cache,\r\n    });\r\n    visit(mirror, (visitedNode) => {\r\n        if (onVisit) {\r\n            onVisit(visitedNode);\r\n        }\r\n        handleScroll(visitedNode, mirror);\r\n    });\r\n    return node;\r\n}\n\nexport { IGNORED_NODE, Mirror, NodeType, adaptCssForReplay, buildNodeWithSN, classMatchesRegex, cleanupSnapshot, createCache, createMirror, escapeImportStatement, extractFileExtension, fixSafariColons, genId, getInputType, ignoreAttribute, is2DCanvasBlank, isCSSImportRule, isCSSStyleRule, isElement, isNativeShadowDom, isNodeMetaEqual, isShadowRoot, maskInputValue, needMaskingText, rebuild, serializeNodeWithId, snapshot, stringifyRule, stringifyStylesheet, toLowerCase, transformAttribute, visitSnapshot };\n","export function parseCSSText(cssText: string): Record<string, string> {\n  const res: Record<string, string> = {};\n  const listDelimiter = /;(?![^(]*\\))/g;\n  const propertyDelimiter = /:(.+)/;\n  const comment = /\\/\\*.*?\\*\\//g;\n  cssText\n    .replace(comment, '')\n    .split(listDelimiter)\n    .forEach(function (item) {\n      if (item) {\n        const tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[camelize(tmp[0].trim())] = tmp[1].trim());\n      }\n    });\n  return res;\n}\n\nexport function toCSSText(style: Record<string, string>): string {\n  const properties = [];\n  for (const name in style) {\n    const value = style[name];\n    if (typeof value !== 'string') continue;\n    const normalizedName = hyphenate(name);\n    properties.push(`${normalizedName}: ${value};`);\n  }\n  return properties.join(' ');\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nconst camelizeRE = /-([a-z])/g;\nconst CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9-]+$/;\nexport const camelize = (str: string): string => {\n  if (CUSTOM_PROPERTY_REGEX.test(str)) return str;\n  return str.replace(camelizeRE, (_, c: string) => (c ? c.toUpperCase() : ''));\n};\n\n/**\n * Hyphenate a camelCase string.\n */\nconst hyphenateRE = /\\B([A-Z])/g;\nexport const hyphenate = (str: string): string => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase();\n};\n","import { NodeType as RRNodeType } from 'rrweb-snapshot';\nimport { parseCSSText, camelize, toCSSText } from './style';\nexport interface IRRNode {\n  parentElement: IRRNode | null;\n  parentNode: IRRNode | null;\n  ownerDocument: IRRDocument;\n  readonly childNodes: IRRNode[];\n  readonly ELEMENT_NODE: number;\n  readonly TEXT_NODE: number;\n  // corresponding nodeType value of standard HTML Node\n  readonly nodeType: number;\n  readonly nodeName: string; // https://dom.spec.whatwg.org/#dom-node-nodename\n  readonly RRNodeType: RRNodeType;\n\n  firstChild: IRRNode | null;\n\n  lastChild: IRRNode | null;\n\n  previousSibling: IRRNode | null;\n\n  nextSibling: IRRNode | null;\n\n  // If the node is a document or a doctype, textContent returns null.\n  textContent: string | null;\n\n  contains(node: IRRNode): boolean;\n\n  appendChild(newChild: IRRNode): IRRNode;\n\n  insertBefore(newChild: IRRNode, refChild: IRRNode | null): IRRNode;\n\n  removeChild(node: IRRNode): IRRNode;\n\n  toString(): string;\n}\nexport interface IRRDocument extends IRRNode {\n  documentElement: IRRElement | null;\n\n  body: IRRElement | null;\n\n  head: IRRElement | null;\n\n  implementation: IRRDocument;\n\n  firstElementChild: IRRElement | null;\n\n  readonly nodeName: '#document';\n\n  compatMode: 'BackCompat' | 'CSS1Compat';\n\n  createDocument(\n    _namespace: string | null,\n    _qualifiedName: string | null,\n    _doctype?: DocumentType | null,\n  ): IRRDocument;\n\n  createDocumentType(\n    qualifiedName: string,\n    publicId: string,\n    systemId: string,\n  ): IRRDocumentType;\n\n  createElement(tagName: string): IRRElement;\n\n  createElementNS(_namespaceURI: string, qualifiedName: string): IRRElement;\n\n  createTextNode(data: string): IRRText;\n\n  createComment(data: string): IRRComment;\n\n  createCDATASection(data: string): IRRCDATASection;\n\n  open(): void;\n\n  close(): void;\n\n  write(content: string): void;\n}\nexport interface IRRElement extends IRRNode {\n  tagName: string;\n  attributes: Record<string, string>;\n  shadowRoot: IRRElement | null;\n  scrollLeft?: number;\n  scrollTop?: number;\n  id: string;\n  className: string;\n  classList: ClassList;\n  style: CSSStyleDeclaration;\n\n  attachShadow(init: ShadowRootInit): IRRElement;\n\n  getAttribute(name: string): string | null;\n\n  setAttribute(name: string, attribute: string): void;\n\n  setAttributeNS(\n    namespace: string | null,\n    qualifiedName: string,\n    value: string,\n  ): void;\n\n  removeAttribute(name: string): void;\n\n  dispatchEvent(event: Event): boolean;\n}\nexport interface IRRDocumentType extends IRRNode {\n  readonly name: string;\n  readonly publicId: string;\n  readonly systemId: string;\n}\nexport interface IRRText extends IRRNode {\n  readonly nodeName: '#text';\n  data: string;\n}\nexport interface IRRComment extends IRRNode {\n  readonly nodeName: '#comment';\n  data: string;\n}\nexport interface IRRCDATASection extends IRRNode {\n  readonly nodeName: '#cdata-section';\n  data: string;\n}\n\ntype ConstrainedConstructor<T = Record<string, unknown>> = new (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: any[]\n) => T;\n\n/**\n * This is designed as an abstract class so it should never be instantiated.\n */\nexport class BaseRRNode implements IRRNode {\n  public parentElement: IRRNode | null = null;\n  public parentNode: IRRNode | null = null;\n  public ownerDocument: IRRDocument;\n  public firstChild: IRRNode | null = null;\n  public lastChild: IRRNode | null = null;\n  public previousSibling: IRRNode | null = null;\n  public nextSibling: IRRNode | null = null;\n\n  public textContent: string | null;\n\n  public readonly ELEMENT_NODE: number = NodeType.ELEMENT_NODE;\n  public readonly TEXT_NODE: number = NodeType.TEXT_NODE;\n  // corresponding nodeType value of standard HTML Node\n  public readonly nodeType: number;\n  public readonly nodeName: string;\n  public readonly RRNodeType: RRNodeType;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n  constructor(..._args: any[]) {\n    //\n  }\n\n  public get childNodes(): IRRNode[] {\n    const childNodes: IRRNode[] = [];\n    let childIterator: IRRNode | null = this.firstChild;\n    while (childIterator) {\n      childNodes.push(childIterator);\n      childIterator = childIterator.nextSibling;\n    }\n    return childNodes;\n  }\n\n  public contains(node: IRRNode) {\n    if (!(node instanceof BaseRRNode)) return false;\n    else if (node.ownerDocument !== this.ownerDocument) return false;\n    else if (node === this) return true;\n\n    while (node.parentNode) {\n      if (node.parentNode === this) return true;\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public appendChild(_newChild: IRRNode): IRRNode {\n    throw new Error(\n      `RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.`,\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public insertBefore(_newChild: IRRNode, _refChild: IRRNode | null): IRRNode {\n    throw new Error(\n      `RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.`,\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public removeChild(_node: IRRNode): IRRNode {\n    throw new Error(\n      `RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.`,\n    );\n  }\n\n  public toString(): string {\n    return 'RRNode';\n  }\n}\n\nexport function BaseRRDocumentImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  return class BaseRRDocument extends RRNodeClass implements IRRDocument {\n    public readonly nodeType: number = NodeType.DOCUMENT_NODE;\n    public readonly nodeName: '#document' = '#document';\n    public readonly compatMode: 'BackCompat' | 'CSS1Compat' = 'CSS1Compat';\n    public readonly RRNodeType = RRNodeType.Document;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(...args: any[]) {\n      super(args);\n      this.textContent = null;\n      this.ownerDocument = this;\n    }\n\n    public get documentElement(): IRRElement | null {\n      return (\n        (this.childNodes.find(\n          (node) =>\n            node.RRNodeType === RRNodeType.Element &&\n            (node as IRRElement).tagName === 'HTML',\n        ) as IRRElement) || null\n      );\n    }\n\n    public get body(): IRRElement | null {\n      return (\n        (this.documentElement?.childNodes.find(\n          (node) =>\n            node.RRNodeType === RRNodeType.Element &&\n            (node as IRRElement).tagName === 'BODY',\n        ) as IRRElement) || null\n      );\n    }\n\n    public get head(): IRRElement | null {\n      return (\n        (this.documentElement?.childNodes.find(\n          (node) =>\n            node.RRNodeType === RRNodeType.Element &&\n            (node as IRRElement).tagName === 'HEAD',\n        ) as IRRElement) || null\n      );\n    }\n\n    public get implementation(): IRRDocument {\n      return this;\n    }\n\n    public get firstElementChild(): IRRElement | null {\n      return this.documentElement;\n    }\n\n    public appendChild(newChild: IRRNode): IRRNode {\n      const nodeType = newChild.RRNodeType;\n      if (\n        nodeType === RRNodeType.Element ||\n        nodeType === RRNodeType.DocumentType\n      ) {\n        if (this.childNodes.some((s) => s.RRNodeType === nodeType)) {\n          throw new Error(\n            `RRDomException: Failed to execute 'appendChild' on 'RRNode': Only one ${\n              nodeType === RRNodeType.Element ? 'RRElement' : 'RRDoctype'\n            } on RRDocument allowed.`,\n          );\n        }\n      }\n\n      const child = appendChild(this, newChild);\n      child.parentElement = null;\n      return child;\n    }\n\n    public insertBefore(newChild: IRRNode, refChild: IRRNode | null): IRRNode {\n      const nodeType = newChild.RRNodeType;\n      if (\n        nodeType === RRNodeType.Element ||\n        nodeType === RRNodeType.DocumentType\n      ) {\n        if (this.childNodes.some((s) => s.RRNodeType === nodeType)) {\n          throw new Error(\n            `RRDomException: Failed to execute 'insertBefore' on 'RRNode': Only one ${\n              nodeType === RRNodeType.Element ? 'RRElement' : 'RRDoctype'\n            } on RRDocument allowed.`,\n          );\n        }\n      }\n\n      const child = insertBefore(this, newChild, refChild);\n      child.parentElement = null;\n      return child;\n    }\n\n    public removeChild(node: IRRNode): IRRNode {\n      return removeChild(this, node);\n    }\n\n    public open() {\n      this.firstChild = null;\n      this.lastChild = null;\n    }\n\n    public close() {\n      //\n    }\n\n    /**\n     * Adhoc implementation for setting xhtml namespace in rebuilt.ts (rrweb-snapshot).\n     * There are two lines used this function:\n     * 1. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\"\\>')\n     * 2. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\"\\>')\n     */\n    public write(content: string) {\n      let publicId;\n      if (\n        content ===\n        '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">'\n      )\n        publicId = '-//W3C//DTD XHTML 1.0 Transitional//EN';\n      else if (\n        content ===\n        '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">'\n      )\n        publicId = '-//W3C//DTD HTML 4.0 Transitional//EN';\n      if (publicId) {\n        const doctype = this.createDocumentType('html', publicId, '');\n        this.open();\n        this.appendChild(doctype);\n      }\n    }\n\n    createDocument(\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      _namespace: string | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      _qualifiedName: string | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      _doctype?: DocumentType | null,\n    ): IRRDocument {\n      return new BaseRRDocument();\n    }\n\n    createDocumentType(\n      qualifiedName: string,\n      publicId: string,\n      systemId: string,\n    ): IRRDocumentType {\n      const doctype = new (BaseRRDocumentTypeImpl(BaseRRNode))(\n        qualifiedName,\n        publicId,\n        systemId,\n      );\n      doctype.ownerDocument = this;\n      return doctype;\n    }\n\n    createElement(tagName: string): IRRElement {\n      const element = new (BaseRRElementImpl(BaseRRNode))(tagName);\n      element.ownerDocument = this;\n      return element;\n    }\n\n    createElementNS(_namespaceURI: string, qualifiedName: string): IRRElement {\n      return this.createElement(qualifiedName);\n    }\n\n    createTextNode(data: string): IRRText {\n      const text = new (BaseRRTextImpl(BaseRRNode))(data);\n      text.ownerDocument = this;\n      return text;\n    }\n\n    createComment(data: string): IRRComment {\n      const comment = new (BaseRRCommentImpl(BaseRRNode))(data);\n      comment.ownerDocument = this;\n      return comment;\n    }\n\n    createCDATASection(data: string): IRRCDATASection {\n      const CDATASection = new (BaseRRCDATASectionImpl(BaseRRNode))(data);\n      CDATASection.ownerDocument = this;\n      return CDATASection;\n    }\n\n    toString() {\n      return 'RRDocument';\n    }\n  };\n}\n\nexport function BaseRRDocumentTypeImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRDocumentType\n    extends RRNodeClass\n    implements IRRDocumentType\n  {\n    public readonly nodeType: number = NodeType.DOCUMENT_TYPE_NODE;\n    public readonly RRNodeType = RRNodeType.DocumentType;\n    public readonly nodeName: string;\n    public readonly name: string;\n    public readonly publicId: string;\n    public readonly systemId: string;\n\n    constructor(qualifiedName: string, publicId: string, systemId: string) {\n      super();\n      this.name = qualifiedName;\n      this.publicId = publicId;\n      this.systemId = systemId;\n      this.nodeName = qualifiedName;\n      this.textContent = null;\n    }\n\n    toString() {\n      return 'RRDocumentType';\n    }\n  };\n}\n\nexport function BaseRRElementImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRElement extends RRNodeClass implements IRRElement {\n    public readonly nodeType: number = NodeType.ELEMENT_NODE;\n    public readonly RRNodeType = RRNodeType.Element;\n    public readonly nodeName: string;\n    public tagName: string;\n    public attributes: Record<string, string> = {};\n    public shadowRoot: IRRElement | null = null;\n    public scrollLeft?: number;\n    public scrollTop?: number;\n\n    constructor(tagName: string) {\n      super();\n      this.tagName = tagName.toUpperCase();\n      this.nodeName = tagName.toUpperCase();\n    }\n\n    public get textContent(): string {\n      let result = '';\n      this.childNodes.forEach((node) => (result += node.textContent));\n      return result;\n    }\n\n    public set textContent(textContent: string) {\n      this.firstChild = null;\n      this.lastChild = null;\n      this.appendChild(this.ownerDocument.createTextNode(textContent));\n    }\n\n    public get classList(): ClassList {\n      return new ClassList(\n        this.attributes.class as string | undefined,\n        (newClassName) => {\n          this.attributes.class = newClassName;\n        },\n      );\n    }\n\n    public get id() {\n      return this.attributes.id || '';\n    }\n\n    public get className() {\n      return this.attributes.class || '';\n    }\n\n    public get style() {\n      const style = (\n        this.attributes.style ? parseCSSText(this.attributes.style) : {}\n      ) as CSSStyleDeclaration;\n      const hyphenateRE = /\\B([A-Z])/g;\n      style.setProperty = (\n        name: string,\n        value: string | null,\n        priority?: string,\n      ) => {\n        if (hyphenateRE.test(name)) return;\n        const normalizedName = camelize(name);\n        if (!value) delete style[normalizedName];\n        else style[normalizedName] = value;\n        if (priority === 'important') style[normalizedName] += ' !important';\n        this.attributes.style = toCSSText(style);\n      };\n      style.removeProperty = (name: string) => {\n        if (hyphenateRE.test(name)) return '';\n        const normalizedName = camelize(name);\n        const value = style[normalizedName] || '';\n        delete style[normalizedName];\n        this.attributes.style = toCSSText(style);\n        return value;\n      };\n      return style;\n    }\n\n    public getAttribute(name: string) {\n      return this.attributes[name] || null;\n    }\n\n    public setAttribute(name: string, attribute: string) {\n      this.attributes[name] = attribute;\n    }\n\n    public setAttributeNS(\n      _namespace: string | null,\n      qualifiedName: string,\n      value: string,\n    ): void {\n      this.setAttribute(qualifiedName, value);\n    }\n\n    public removeAttribute(name: string) {\n      delete this.attributes[name];\n    }\n\n    public appendChild(newChild: IRRNode): IRRNode {\n      return appendChild(this, newChild);\n    }\n\n    public insertBefore(newChild: IRRNode, refChild: IRRNode | null): IRRNode {\n      return insertBefore(this, newChild, refChild);\n    }\n\n    public removeChild(node: IRRNode): IRRNode {\n      return removeChild(this, node);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public attachShadow(_init: ShadowRootInit): IRRElement {\n      const shadowRoot = this.ownerDocument.createElement('SHADOWROOT');\n      this.shadowRoot = shadowRoot;\n      return shadowRoot;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public dispatchEvent(_event: Event) {\n      return true;\n    }\n\n    toString() {\n      let attributeString = '';\n      for (const attribute in this.attributes) {\n        attributeString += `${attribute}=\"${this.attributes[attribute]}\" `;\n      }\n      return `${this.tagName} ${attributeString}`;\n    }\n  };\n}\n\nexport function BaseRRMediaElementImpl<\n  RRElement extends ConstrainedConstructor<IRRElement>,\n>(RRElementClass: RRElement) {\n  return class BaseRRMediaElement extends RRElementClass {\n    public currentTime?: number;\n    public volume?: number;\n    public paused?: boolean;\n    public muted?: boolean;\n    public playbackRate?: number;\n    public loop?: boolean;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    attachShadow(_init: ShadowRootInit): IRRElement {\n      throw new Error(\n        `RRDomException: Failed to execute 'attachShadow' on 'RRElement': This RRElement does not support attachShadow`,\n      );\n    }\n    public play() {\n      this.paused = false;\n    }\n    public pause() {\n      this.paused = true;\n    }\n  };\n}\n\nexport function BaseRRTextImpl<RRNode extends ConstrainedConstructor<IRRNode>>(\n  RRNodeClass: RRNode,\n) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRText extends RRNodeClass implements IRRText {\n    public readonly nodeType: number = NodeType.TEXT_NODE;\n    public readonly nodeName: '#text' = '#text';\n    public readonly RRNodeType = RRNodeType.Text;\n    public data: string;\n\n    constructor(data: string) {\n      super();\n      this.data = data;\n    }\n\n    public get textContent(): string {\n      return this.data;\n    }\n\n    public set textContent(textContent: string) {\n      this.data = textContent;\n    }\n\n    toString() {\n      return `RRText text=${JSON.stringify(this.data)}`;\n    }\n  };\n}\n\nexport function BaseRRCommentImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRComment extends RRNodeClass implements IRRComment {\n    public readonly nodeType: number = NodeType.COMMENT_NODE;\n    public readonly nodeName: '#comment' = '#comment';\n    public readonly RRNodeType = RRNodeType.Comment;\n    public data: string;\n\n    constructor(data: string) {\n      super();\n      this.data = data;\n    }\n\n    public get textContent(): string {\n      return this.data;\n    }\n\n    public set textContent(textContent: string) {\n      this.data = textContent;\n    }\n\n    toString() {\n      return `RRComment text=${JSON.stringify(this.data)}`;\n    }\n  };\n}\n\nexport function BaseRRCDATASectionImpl<\n  RRNode extends ConstrainedConstructor<IRRNode>,\n>(RRNodeClass: RRNode) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return class BaseRRCDATASection\n    extends RRNodeClass\n    implements IRRCDATASection\n  {\n    public readonly nodeName: '#cdata-section' = '#cdata-section';\n    public readonly nodeType: number = NodeType.CDATA_SECTION_NODE;\n    public readonly RRNodeType = RRNodeType.CDATA;\n    public data: string;\n\n    constructor(data: string) {\n      super();\n      this.data = data;\n    }\n\n    public get textContent(): string {\n      return this.data;\n    }\n\n    public set textContent(textContent: string) {\n      this.data = textContent;\n    }\n\n    toString() {\n      return `RRCDATASection data=${JSON.stringify(this.data)}`;\n    }\n  };\n}\n\nexport class ClassList {\n  private onChange: ((newClassText: string) => void) | undefined;\n  classes: string[] = [];\n\n  constructor(\n    classText?: string,\n    onChange?: ((newClassText: string) => void) | undefined,\n  ) {\n    if (classText) {\n      const classes = classText.trim().split(/\\s+/);\n      this.classes.push(...classes);\n    }\n    this.onChange = onChange;\n  }\n\n  add = (...classNames: string[]) => {\n    for (const item of classNames) {\n      const className = String(item);\n      if (this.classes.indexOf(className) >= 0) continue;\n      this.classes.push(className);\n    }\n    this.onChange && this.onChange(this.classes.join(' '));\n  };\n\n  remove = (...classNames: string[]) => {\n    this.classes = this.classes.filter(\n      (item) => classNames.indexOf(item) === -1,\n    );\n    this.onChange && this.onChange(this.classes.join(' '));\n  };\n}\n\nexport type CSSStyleDeclaration = Record<string, string> & {\n  setProperty: (\n    name: string,\n    value: string | null,\n    priority?: string | null,\n  ) => void;\n  removeProperty: (name: string) => string;\n};\n\nfunction appendChild(parent: IRRNode, newChild: IRRNode) {\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n\n  if (parent.lastChild) {\n    parent.lastChild.nextSibling = newChild;\n    newChild.previousSibling = parent.lastChild;\n  } else {\n    parent.firstChild = newChild;\n    newChild.previousSibling = null;\n  }\n  parent.lastChild = newChild;\n  newChild.nextSibling = null;\n  newChild.parentNode = parent;\n  newChild.parentElement = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\n\nfunction insertBefore(\n  parent: IRRNode,\n  newChild: IRRNode,\n  refChild: IRRNode | null,\n) {\n  if (!refChild) return appendChild(parent, newChild);\n\n  if (refChild.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'insertBefore' on 'RRNode': The RRNode before which the new node is to be inserted is not a child of this RRNode.\",\n    );\n\n  if (newChild === refChild) return newChild;\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n\n  newChild.previousSibling = refChild.previousSibling;\n  refChild.previousSibling = newChild;\n  newChild.nextSibling = refChild;\n\n  if (newChild.previousSibling) newChild.previousSibling.nextSibling = newChild;\n  else parent.firstChild = newChild;\n\n  newChild.parentElement = parent;\n  newChild.parentNode = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\n\nfunction removeChild(parent: IRRNode, child: IRRNode) {\n  if (child.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'removeChild' on 'RRNode': The RRNode to be removed is not a child of this RRNode.\",\n    );\n  if (child.previousSibling)\n    child.previousSibling.nextSibling = child.nextSibling;\n  else parent.firstChild = child.nextSibling;\n  if (child.nextSibling)\n    child.nextSibling.previousSibling = child.previousSibling;\n  else parent.lastChild = child.previousSibling;\n  child.previousSibling = null;\n  child.nextSibling = null;\n  child.parentElement = null;\n  child.parentNode = null;\n  return child;\n}\n\n// Enumerate nodeType value of standard HTML Node.\nexport enum NodeType {\n  PLACEHOLDER, // This isn't a node type. Enum type value starts from zero but NodeType value starts from 1.\n  ELEMENT_NODE,\n  ATTRIBUTE_NODE,\n  TEXT_NODE,\n  CDATA_SECTION_NODE,\n  ENTITY_REFERENCE_NODE,\n  ENTITY_NODE,\n  PROCESSING_INSTRUCTION_NODE,\n  COMMENT_NODE,\n  DOCUMENT_NODE,\n  DOCUMENT_TYPE_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n}\n","import {\n  NodeType as RRNodeType,\n  Mirror as NodeMirror,\n  elementNode,\n} from 'rrweb-snapshot';\nimport type {\n  canvasMutationData,\n  canvasEventWithTime,\n  inputData,\n  scrollData,\n  styleDeclarationData,\n  styleSheetRuleData,\n} from '@rrweb/types';\nimport type {\n  IRRCDATASection,\n  IRRComment,\n  IRRDocumentType,\n  IRRElement,\n  IRRNode,\n  IRRText,\n} from './document';\nimport type {\n  RRCanvasElement,\n  RRElement,\n  RRIFrameElement,\n  RRMediaElement,\n  RRStyleElement,\n  RRDocument,\n  Mirror,\n} from '.';\n\nconst NAMESPACES: Record<string, string> = {\n  svg: 'http://www.w3.org/2000/svg',\n  'xlink:href': 'http://www.w3.org/1999/xlink',\n  xmlns: 'http://www.w3.org/2000/xmlns/',\n};\n\n// camel case svg element tag names\nconst SVGTagMap: Record<string, string> = {\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\n\nexport type ReplayerHandler = {\n  mirror: NodeMirror;\n  applyCanvas: (\n    canvasEvent: canvasEventWithTime,\n    canvasMutationData: canvasMutationData,\n    target: HTMLCanvasElement,\n  ) => void;\n  applyInput: (data: inputData) => void;\n  applyScroll: (data: scrollData, isSync: boolean) => void;\n  applyStyleSheetMutation: (\n    data: styleDeclarationData | styleSheetRuleData,\n    styleSheet: CSSStyleSheet,\n  ) => void;\n  // Similar to the `afterAppend` callback in the `rrweb-snapshot` package. It's a postorder traversal of the newly appended nodes.\n  afterAppend?(node: Node, id: number): void;\n};\n\n// A set contains newly appended nodes. It's used to make sure the afterAppend callback can iterate newly appended nodes in the same traversal order as that in the `rrweb-snapshot` package.\nlet createdNodeSet: WeakSet<Node> | null = null;\n\n/**\n * Make the old tree to have the same structure and properties as the new tree with the diff algorithm.\n * @param oldTree - The old tree to be modified.\n * @param newTree - The new tree which the old tree will be modified to.\n * @param replayer - A slimmed replayer instance including the mirror of the old tree.\n * @param rrnodeMirror - The mirror of the new tree.\n */\nexport function diff(\n  oldTree: Node,\n  newTree: IRRNode,\n  replayer: ReplayerHandler,\n  rrnodeMirror: Mirror = (newTree as RRDocument).mirror ||\n    (newTree.ownerDocument as RRDocument).mirror,\n) {\n  oldTree = diffBeforeUpdatingChildren(\n    oldTree,\n    newTree,\n    replayer,\n    rrnodeMirror,\n  );\n\n  diffChildren(oldTree, newTree, replayer, rrnodeMirror);\n\n  diffAfterUpdatingChildren(oldTree, newTree, replayer);\n}\n\n/**\n * Do some preparation work before updating the children of the old tree.\n */\nfunction diffBeforeUpdatingChildren(\n  oldTree: Node,\n  newTree: IRRNode,\n  replayer: ReplayerHandler,\n  rrnodeMirror: Mirror,\n) {\n  if (replayer.afterAppend && !createdNodeSet) {\n    createdNodeSet = new WeakSet();\n    setTimeout(() => {\n      createdNodeSet = null;\n    }, 0);\n  }\n  // If the Mirror data has some flaws, the diff function may throw errors. We check the node consistency here to make it robust.\n  if (!sameNodeType(oldTree, newTree)) {\n    const calibratedOldTree = createOrGetNode(\n      newTree,\n      replayer.mirror,\n      rrnodeMirror,\n    );\n    oldTree.parentNode?.replaceChild(calibratedOldTree, oldTree);\n    oldTree = calibratedOldTree;\n  }\n  switch (newTree.RRNodeType) {\n    case RRNodeType.Document: {\n      /**\n       * Special cases for updating the document node:\n       * Case 1: If the oldTree is the content document of an iframe element and its content (HTML, HEAD, and BODY) is automatically mounted by browsers, we need to remove them to avoid unexpected behaviors. e.g. Selector matches may be case insensitive.\n       * Case 2: The newTree has a different serialized Id (a different document object), we need to reopen it and update the nodeMirror.\n       */\n      if (!nodeMatching(oldTree, newTree, replayer.mirror, rrnodeMirror)) {\n        const newMeta = rrnodeMirror.getMeta(newTree);\n        if (newMeta) {\n          replayer.mirror.removeNodeFromMap(oldTree);\n          (oldTree as Document).close();\n          (oldTree as Document).open();\n          replayer.mirror.add(oldTree, newMeta);\n          createdNodeSet?.add(oldTree);\n        }\n      }\n      break;\n    }\n    case RRNodeType.Element: {\n      const oldElement = oldTree as HTMLElement;\n      const newRRElement = newTree as IRRElement;\n      switch (newRRElement.tagName) {\n        case 'IFRAME': {\n          const oldContentDocument = (oldTree as HTMLIFrameElement)\n            .contentDocument;\n          // If the iframe is cross-origin, the contentDocument will be null.\n          if (!oldContentDocument) break;\n          // IFrame element doesn't have child nodes, so here we update its content document separately.\n          diff(\n            oldContentDocument,\n            (newTree as RRIFrameElement).contentDocument,\n            replayer,\n            rrnodeMirror,\n          );\n          break;\n        }\n      }\n      if (newRRElement.shadowRoot) {\n        if (!oldElement.shadowRoot) oldElement.attachShadow({ mode: 'open' });\n        diffChildren(\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          oldElement.shadowRoot!,\n          newRRElement.shadowRoot,\n          replayer,\n          rrnodeMirror,\n        );\n      }\n      /**\n       * Attributes and styles of the old element need to be updated before updating its children because of an edge case:\n       * `applyScroll` may fail in `diffAfterUpdatingChildren` when the height of a node when `applyScroll` is called may be incorrect if\n       * 1. its parent node contains styles that affects the targeted node's height\n       * 2. the CSS selector is targeting an attribute of the parent node\n       * by running `diffProps` on the parent node before `diffChildren` is called,\n       * we can ensure that the correct attributes (and therefore styles) have applied to parent nodes\n       */\n      diffProps(oldElement, newRRElement, rrnodeMirror);\n      break;\n    }\n  }\n  return oldTree;\n}\n\n/**\n * Finish the diff work after updating the children of the old tree.\n */\nfunction diffAfterUpdatingChildren(\n  oldTree: Node,\n  newTree: IRRNode,\n  replayer: ReplayerHandler,\n) {\n  switch (newTree.RRNodeType) {\n    case RRNodeType.Document: {\n      const scrollData = (newTree as RRDocument).scrollData;\n      scrollData && replayer.applyScroll(scrollData, true);\n      break;\n    }\n    case RRNodeType.Element: {\n      const oldElement = oldTree as HTMLElement;\n      const newRRElement = newTree as RRElement;\n      newRRElement.scrollData &&\n        replayer.applyScroll(newRRElement.scrollData, true);\n      /**\n       * Input data need to get applied after all children of this node are updated.\n       * Otherwise when we set a value for a select element whose options are empty, the value won't actually update.\n       */\n      newRRElement.inputData && replayer.applyInput(newRRElement.inputData);\n      switch (newRRElement.tagName) {\n        case 'AUDIO':\n        case 'VIDEO': {\n          const oldMediaElement = oldTree as HTMLMediaElement;\n          const newMediaRRElement = newRRElement as RRMediaElement;\n          if (newMediaRRElement.paused !== undefined)\n            newMediaRRElement.paused\n              ? void oldMediaElement.pause()\n              : void oldMediaElement.play();\n          if (newMediaRRElement.muted !== undefined)\n            oldMediaElement.muted = newMediaRRElement.muted;\n          if (newMediaRRElement.volume !== undefined)\n            oldMediaElement.volume = newMediaRRElement.volume;\n          if (newMediaRRElement.currentTime !== undefined)\n            oldMediaElement.currentTime = newMediaRRElement.currentTime;\n          if (newMediaRRElement.playbackRate !== undefined)\n            oldMediaElement.playbackRate = newMediaRRElement.playbackRate;\n          if (newMediaRRElement.loop !== undefined)\n            oldMediaElement.loop = newMediaRRElement.loop;\n          break;\n        }\n        case 'CANVAS': {\n          const rrCanvasElement = newTree as RRCanvasElement;\n          // This canvas element is created with initial data in an iframe element. https://github.com/rrweb-io/rrweb/pull/944\n          if (rrCanvasElement.rr_dataURL !== null) {\n            const image = document.createElement('img');\n            image.onload = () => {\n              const ctx = (oldElement as HTMLCanvasElement).getContext('2d');\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n            image.src = rrCanvasElement.rr_dataURL;\n          }\n          rrCanvasElement.canvasMutations.forEach((canvasMutation) =>\n            replayer.applyCanvas(\n              canvasMutation.event,\n              canvasMutation.mutation,\n              oldTree as HTMLCanvasElement,\n            ),\n          );\n          break;\n        }\n        // Props of style elements have to be updated after all children are updated. Otherwise the props can be overwritten by textContent.\n        case 'STYLE': {\n          const styleSheet = (oldElement as HTMLStyleElement).sheet;\n          styleSheet &&\n            (newTree as RRStyleElement).rules.forEach((data) =>\n              replayer.applyStyleSheetMutation(data, styleSheet),\n            );\n          break;\n        }\n      }\n      break;\n    }\n    case RRNodeType.Text:\n    case RRNodeType.Comment:\n    case RRNodeType.CDATA: {\n      if (\n        oldTree.textContent !==\n        (newTree as IRRText | IRRComment | IRRCDATASection).data\n      )\n        oldTree.textContent = (\n          newTree as IRRText | IRRComment | IRRCDATASection\n        ).data;\n      break;\n    }\n  }\n  if (createdNodeSet?.has(oldTree)) {\n    createdNodeSet.delete(oldTree);\n    replayer.afterAppend?.(oldTree, replayer.mirror.getId(oldTree));\n  }\n}\n\nfunction diffProps(\n  oldTree: HTMLElement,\n  newTree: IRRElement,\n  rrnodeMirror: Mirror,\n) {\n  const oldAttributes = oldTree.attributes;\n  const newAttributes = newTree.attributes;\n\n  for (const name in newAttributes) {\n    const newValue = newAttributes[name];\n    const sn = rrnodeMirror.getMeta(newTree) as elementNode | null;\n    if (sn?.isSVG && NAMESPACES[name])\n      oldTree.setAttributeNS(NAMESPACES[name], name, newValue);\n    else if (newTree.tagName === 'CANVAS' && name === 'rr_dataURL') {\n      const image = document.createElement('img');\n      image.src = newValue;\n      image.onload = () => {\n        const ctx = (oldTree as HTMLCanvasElement).getContext('2d');\n        if (ctx) {\n          ctx.drawImage(image, 0, 0, image.width, image.height);\n        }\n      };\n    } else if (newTree.tagName === 'IFRAME' && name === 'srcdoc') continue;\n    else oldTree.setAttribute(name, newValue);\n  }\n\n  for (const { name } of Array.from(oldAttributes))\n    if (!(name in newAttributes)) oldTree.removeAttribute(name);\n\n  newTree.scrollLeft && (oldTree.scrollLeft = newTree.scrollLeft);\n  newTree.scrollTop && (oldTree.scrollTop = newTree.scrollTop);\n}\n\nfunction diffChildren(\n  oldTree: Node,\n  newTree: IRRNode,\n  replayer: ReplayerHandler,\n  rrnodeMirror: Mirror,\n) {\n  const oldChildren: (Node | undefined)[] = Array.from(oldTree.childNodes);\n  const newChildren = newTree.childNodes;\n  if (oldChildren.length === 0 && newChildren.length === 0) return;\n  let oldStartIndex = 0,\n    oldEndIndex = oldChildren.length - 1,\n    newStartIndex = 0,\n    newEndIndex = newChildren.length - 1;\n  let oldStartNode = oldChildren[oldStartIndex],\n    oldEndNode = oldChildren[oldEndIndex],\n    newStartNode = newChildren[newStartIndex],\n    newEndNode = newChildren[newEndIndex];\n  let oldIdToIndex: Record<number, number> | undefined = undefined,\n    indexInOld: number | undefined = undefined;\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    if (oldStartNode === undefined) {\n      oldStartNode = oldChildren[++oldStartIndex];\n    } else if (oldEndNode === undefined) {\n      oldEndNode = oldChildren[--oldEndIndex];\n    } else if (\n      // same first node?\n      nodeMatching(oldStartNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldStartNode = oldChildren[++oldStartIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else if (\n      // same last node?\n      nodeMatching(oldEndNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldEndNode = oldChildren[--oldEndIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the first old node the same as the last new node?\n      nodeMatching(oldStartNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        oldTree.insertBefore(oldStartNode, oldEndNode.nextSibling);\n      } catch (e) {\n        console.warn(e);\n      }\n      oldStartNode = oldChildren[++oldStartIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the last old node the same as the first new node?\n      nodeMatching(oldEndNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        oldTree.insertBefore(oldEndNode, oldStartNode);\n      } catch (e) {\n        console.warn(e);\n      }\n      oldEndNode = oldChildren[--oldEndIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else {\n      // none of the elements matched\n\n      if (!oldIdToIndex) {\n        oldIdToIndex = {};\n        for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n          const oldChild = oldChildren[i];\n          if (oldChild && replayer.mirror.hasNode(oldChild))\n            oldIdToIndex[replayer.mirror.getId(oldChild)] = i;\n        }\n      }\n      indexInOld = oldIdToIndex[rrnodeMirror.getId(newStartNode)];\n      const nodeToMove = oldChildren[indexInOld];\n      if (\n        indexInOld !== undefined &&\n        nodeToMove &&\n        nodeMatching(nodeToMove, newStartNode, replayer.mirror, rrnodeMirror)\n      ) {\n        try {\n          oldTree.insertBefore(nodeToMove, oldStartNode);\n        } catch (e) {\n          console.warn(e);\n        }\n        oldChildren[indexInOld] = undefined;\n      } else {\n        const newNode = createOrGetNode(\n          newStartNode,\n          replayer.mirror,\n          rrnodeMirror,\n        );\n\n        if (\n          oldTree.nodeName === '#document' &&\n          oldStartNode &&\n          /**\n           * Special case 1: one document isn't allowed to have two doctype nodes at the same time, so we need to remove the old one first before inserting the new one.\n           * How this case happens: A parent document in the old tree already has a doctype node with an id e.g. #1. A new full snapshot rebuilds the replayer with a new doctype node with another id #2. According to the algorithm, the new doctype node will be inserted before the old one, which is not allowed by the Document standard.\n           */\n          ((newNode.nodeType === newNode.DOCUMENT_TYPE_NODE &&\n            oldStartNode.nodeType === oldStartNode.DOCUMENT_TYPE_NODE) ||\n            /**\n             * Special case 2: one document isn't allowed to have two HTMLElements at the same time, so we need to remove the old one first before inserting the new one.\n             * How this case happens: A mounted iframe element has an automatically created HTML element. We should delete it before inserting a serialized one. Otherwise, an error 'Only one element on document allowed' will be thrown.\n             */\n            (newNode.nodeType === newNode.ELEMENT_NODE &&\n              oldStartNode.nodeType === oldStartNode.ELEMENT_NODE))\n        ) {\n          oldTree.removeChild(oldStartNode);\n          replayer.mirror.removeNodeFromMap(oldStartNode);\n          oldStartNode = oldChildren[++oldStartIndex];\n        }\n\n        try {\n          oldTree.insertBefore(newNode, oldStartNode || null);\n        } catch (e) {\n          console.warn(e);\n        }\n      }\n      newStartNode = newChildren[++newStartIndex];\n    }\n  }\n  if (oldStartIndex > oldEndIndex) {\n    const referenceRRNode = newChildren[newEndIndex + 1];\n    let referenceNode: Node | null = null;\n    if (referenceRRNode)\n      referenceNode = replayer.mirror.getNode(\n        rrnodeMirror.getId(referenceRRNode),\n      );\n    for (; newStartIndex <= newEndIndex; ++newStartIndex) {\n      const newNode = createOrGetNode(\n        newChildren[newStartIndex],\n        replayer.mirror,\n        rrnodeMirror,\n      );\n      try {\n        oldTree.insertBefore(newNode, referenceNode);\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n  } else if (newStartIndex > newEndIndex) {\n    for (; oldStartIndex <= oldEndIndex; oldStartIndex++) {\n      const node = oldChildren[oldStartIndex];\n      if (!node || node.parentNode !== oldTree) continue;\n      try {\n        oldTree.removeChild(node);\n        replayer.mirror.removeNodeFromMap(node);\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n  }\n\n  // Recursively diff the children of the old tree and the new tree with their props and deeper structures.\n  let oldChild = oldTree.firstChild;\n  let newChild = newTree.firstChild;\n  while (oldChild !== null && newChild !== null) {\n    diff(oldChild, newChild, replayer, rrnodeMirror);\n    oldChild = oldChild.nextSibling;\n    newChild = newChild.nextSibling;\n  }\n}\n\nexport function createOrGetNode(\n  rrNode: IRRNode,\n  domMirror: NodeMirror,\n  rrnodeMirror: Mirror,\n): Node {\n  const nodeId = rrnodeMirror.getId(rrNode);\n  const sn = rrnodeMirror.getMeta(rrNode);\n  let node: Node | null = null;\n  // negative ids shouldn't be compared accross mirrors\n  if (nodeId > -1) node = domMirror.getNode(nodeId);\n  if (node !== null && sameNodeType(node, rrNode)) return node;\n  switch (rrNode.RRNodeType) {\n    case RRNodeType.Document:\n      node = new Document();\n      break;\n    case RRNodeType.DocumentType:\n      node = document.implementation.createDocumentType(\n        (rrNode as IRRDocumentType).name,\n        (rrNode as IRRDocumentType).publicId,\n        (rrNode as IRRDocumentType).systemId,\n      );\n      break;\n    case RRNodeType.Element: {\n      let tagName = (rrNode as IRRElement).tagName.toLowerCase();\n      tagName = SVGTagMap[tagName] || tagName;\n      if (sn && 'isSVG' in sn && sn?.isSVG) {\n        node = document.createElementNS(NAMESPACES['svg'], tagName);\n      } else node = document.createElement((rrNode as IRRElement).tagName);\n      break;\n    }\n    case RRNodeType.Text:\n      node = document.createTextNode((rrNode as IRRText).data);\n      break;\n    case RRNodeType.Comment:\n      node = document.createComment((rrNode as IRRComment).data);\n      break;\n    case RRNodeType.CDATA:\n      node = document.createCDATASection((rrNode as IRRCDATASection).data);\n      break;\n  }\n\n  if (sn) domMirror.add(node, { ...sn });\n  try {\n    createdNodeSet?.add(node);\n  } catch (e) {\n    // Just for safety concern.\n  }\n  return node;\n}\n\n/**\n * To check whether two nodes are the same type of node. If they are both Elements, check wether their tagNames are same or not.\n */\nexport function sameNodeType(node1: Node, node2: IRRNode) {\n  if (node1.nodeType !== node2.nodeType) return false;\n  return (\n    node1.nodeType !== node1.ELEMENT_NODE ||\n    (node1 as HTMLElement).tagName.toUpperCase() ===\n      (node2 as IRRElement).tagName\n  );\n}\n\n/**\n * To check whether two nodes are matching. If so, they are supposed to have the same serialized Id and node type. If they are both Elements, their tagNames should be the same as well. Otherwise, they are not matching.\n */\nexport function nodeMatching(\n  node1: Node,\n  node2: IRRNode,\n  domMirror: NodeMirror,\n  rrdomMirror: Mirror,\n): boolean {\n  const node1Id = domMirror.getId(node1);\n  const node2Id = rrdomMirror.getId(node2);\n  // rrdom contains elements with negative ids, we don't want to accidentally match those to a mirror mismatch (-1) id.\n  // Negative oldStartId happen when nodes are not in the mirror, but are in the DOM.\n  // eg.iframes come with a document, html, head and body nodes.\n  // thats why below we always check if an id is negative.\n  if (node1Id === -1 || node1Id !== node2Id) return false;\n  return sameNodeType(node1, node2);\n}\n","import {\n  NodeType as RRNodeType,\n  createMirror as createNodeMirror,\n} from 'rrweb-snapshot';\nimport type {\n  Mirror as NodeMirror,\n  IMirror,\n  serializedNodeWithId,\n} from 'rrweb-snapshot';\nimport type {\n  canvasMutationData,\n  canvasEventWithTime,\n  inputData,\n  scrollData,\n  styleSheetRuleData,\n  styleDeclarationData,\n} from '@rrweb/types';\nimport {\n  BaseRRNode as RRNode,\n  BaseRRCDATASectionImpl,\n  BaseRRCommentImpl,\n  BaseRRDocumentImpl,\n  BaseRRDocumentTypeImpl,\n  BaseRRElementImpl,\n  BaseRRMediaElementImpl,\n  BaseRRTextImpl,\n  IRRDocument,\n  IRRElement,\n  IRRNode,\n  NodeType,\n  IRRDocumentType,\n  IRRText,\n  IRRComment,\n} from './document';\n\nexport class RRDocument extends BaseRRDocumentImpl(RRNode) {\n  private UNSERIALIZED_STARTING_ID = -2;\n  // In the rrweb replayer, there are some unserialized nodes like the element that stores the injected style rules.\n  // These unserialized nodes may interfere the execution of the diff algorithm.\n  // The id of serialized node is larger than 0. So this value less than 0 is used as id for these unserialized nodes.\n  private _unserializedId = this.UNSERIALIZED_STARTING_ID;\n\n  /**\n   * Every time the id is used, it will minus 1 automatically to avoid collisions.\n   */\n  public get unserializedId(): number {\n    return this._unserializedId--;\n  }\n\n  public mirror: Mirror = createMirror();\n\n  public scrollData: scrollData | null = null;\n\n  constructor(mirror?: Mirror) {\n    super();\n    if (mirror) {\n      this.mirror = mirror;\n    }\n  }\n\n  createDocument(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _namespace: string | null,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _qualifiedName: string | null,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _doctype?: DocumentType | null,\n  ) {\n    return new RRDocument();\n  }\n\n  createDocumentType(\n    qualifiedName: string,\n    publicId: string,\n    systemId: string,\n  ) {\n    const documentTypeNode = new RRDocumentType(\n      qualifiedName,\n      publicId,\n      systemId,\n    );\n    documentTypeNode.ownerDocument = this;\n    return documentTypeNode;\n  }\n\n  createElement<K extends keyof HTMLElementTagNameMap>(\n    tagName: K,\n  ): RRElementType<K>;\n  createElement(tagName: string): RRElement;\n  createElement(tagName: string) {\n    const upperTagName = tagName.toUpperCase();\n    let element;\n    switch (upperTagName) {\n      case 'AUDIO':\n      case 'VIDEO':\n        element = new RRMediaElement(upperTagName);\n        break;\n      case 'IFRAME':\n        element = new RRIFrameElement(upperTagName, this.mirror);\n        break;\n      case 'CANVAS':\n        element = new RRCanvasElement(upperTagName);\n        break;\n      case 'STYLE':\n        element = new RRStyleElement(upperTagName);\n        break;\n      default:\n        element = new RRElement(upperTagName);\n        break;\n    }\n    element.ownerDocument = this;\n    return element;\n  }\n\n  createComment(data: string) {\n    const commentNode = new RRComment(data);\n    commentNode.ownerDocument = this;\n    return commentNode;\n  }\n\n  createCDATASection(data: string) {\n    const sectionNode = new RRCDATASection(data);\n    sectionNode.ownerDocument = this;\n    return sectionNode;\n  }\n\n  createTextNode(data: string) {\n    const textNode = new RRText(data);\n    textNode.ownerDocument = this;\n    return textNode;\n  }\n\n  destroyTree() {\n    this.firstChild = null;\n    this.lastChild = null;\n    this.mirror.reset();\n  }\n\n  open() {\n    super.open();\n    this._unserializedId = this.UNSERIALIZED_STARTING_ID;\n  }\n}\n\nexport const RRDocumentType = BaseRRDocumentTypeImpl(RRNode);\n\nexport class RRElement extends BaseRRElementImpl(RRNode) {\n  inputData: inputData | null = null;\n  scrollData: scrollData | null = null;\n}\n\nexport class RRMediaElement extends BaseRRMediaElementImpl(RRElement) {}\n\nexport class RRCanvasElement extends RRElement implements IRRElement {\n  public rr_dataURL: string | null = null;\n  public canvasMutations: {\n    event: canvasEventWithTime;\n    mutation: canvasMutationData;\n  }[] = [];\n  /**\n   * This is a dummy implementation to distinguish RRCanvasElement from real HTMLCanvasElement.\n   */\n  getContext(): RenderingContext | null {\n    return null;\n  }\n}\n\nexport class RRStyleElement extends RRElement {\n  public rules: (styleSheetRuleData | styleDeclarationData)[] = [];\n}\n\nexport class RRIFrameElement extends RRElement {\n  contentDocument: RRDocument = new RRDocument();\n  constructor(upperTagName: string, mirror: Mirror) {\n    super(upperTagName);\n    this.contentDocument.mirror = mirror;\n  }\n}\n\nexport const RRText = BaseRRTextImpl(RRNode);\nexport type RRText = typeof RRText;\n\nexport const RRComment = BaseRRCommentImpl(RRNode);\nexport type RRComment = typeof RRComment;\n\nexport const RRCDATASection = BaseRRCDATASectionImpl(RRNode);\nexport type RRCDATASection = typeof RRCDATASection;\n\ninterface RRElementTagNameMap {\n  audio: RRMediaElement;\n  canvas: RRCanvasElement;\n  iframe: RRIFrameElement;\n  style: RRStyleElement;\n  video: RRMediaElement;\n}\n\ntype RRElementType<K extends keyof HTMLElementTagNameMap> =\n  K extends keyof RRElementTagNameMap ? RRElementTagNameMap[K] : RRElement;\n\nfunction getValidTagName(element: HTMLElement): string {\n  // https://github.com/rrweb-io/rrweb-snapshot/issues/56\n  if (element instanceof HTMLFormElement) {\n    return 'FORM';\n  }\n  return element.tagName.toUpperCase();\n}\n\n/**\n * Build a RRNode from a real Node.\n * @param node - the real Node\n * @param rrdom - the RRDocument\n * @param domMirror - the NodeMirror that records the real document tree\n * @returns the built RRNode\n */\nexport function buildFromNode(\n  node: Node,\n  rrdom: IRRDocument,\n  domMirror: NodeMirror,\n  parentRRNode?: IRRNode | null,\n): IRRNode | null {\n  let rrNode: IRRNode;\n\n  switch (node.nodeType) {\n    case NodeType.DOCUMENT_NODE:\n      if (parentRRNode && parentRRNode.nodeName === 'IFRAME')\n        rrNode = (parentRRNode as RRIFrameElement).contentDocument;\n      else {\n        rrNode = rrdom;\n        (rrNode as IRRDocument).compatMode = (node as Document).compatMode as\n          | 'BackCompat'\n          | 'CSS1Compat';\n      }\n      break;\n    case NodeType.DOCUMENT_TYPE_NODE: {\n      const documentType = node as DocumentType;\n      rrNode = rrdom.createDocumentType(\n        documentType.name,\n        documentType.publicId,\n        documentType.systemId,\n      );\n      break;\n    }\n    case NodeType.ELEMENT_NODE: {\n      const elementNode = node as HTMLElement;\n      const tagName = getValidTagName(elementNode);\n      rrNode = rrdom.createElement(tagName);\n      const rrElement = rrNode as IRRElement;\n      for (const { name, value } of Array.from(elementNode.attributes)) {\n        rrElement.attributes[name] = value;\n      }\n      elementNode.scrollLeft && (rrElement.scrollLeft = elementNode.scrollLeft);\n      elementNode.scrollTop && (rrElement.scrollTop = elementNode.scrollTop);\n      /**\n       * We don't have to record special values of input elements at the beginning.\n       * Because if these values are changed later, the mutation will be applied through the batched input events on its RRElement after the diff algorithm is executed.\n       */\n      break;\n    }\n    case NodeType.TEXT_NODE:\n      rrNode = rrdom.createTextNode((node as Text).textContent || '');\n      break;\n    case NodeType.CDATA_SECTION_NODE:\n      rrNode = rrdom.createCDATASection((node as CDATASection).data);\n      break;\n    case NodeType.COMMENT_NODE:\n      rrNode = rrdom.createComment((node as Comment).textContent || '');\n      break;\n    // if node is a shadow root\n    case NodeType.DOCUMENT_FRAGMENT_NODE:\n      rrNode = (parentRRNode as IRRElement).attachShadow({ mode: 'open' });\n      break;\n    default:\n      return null;\n  }\n\n  let sn: serializedNodeWithId | null = domMirror.getMeta(node);\n\n  if (rrdom instanceof RRDocument) {\n    if (!sn) {\n      sn = getDefaultSN(rrNode, rrdom.unserializedId);\n      domMirror.add(node, sn);\n    }\n    rrdom.mirror.add(rrNode, { ...sn });\n  }\n\n  return rrNode;\n}\n\n/**\n * Build a RRDocument from a real document tree.\n * @param dom - the real document tree\n * @param domMirror - the NodeMirror that records the real document tree\n * @param rrdom - the rrdom object to be constructed\n * @returns the build rrdom\n */\nexport function buildFromDom(\n  dom: Document,\n  domMirror: NodeMirror = createNodeMirror(),\n  rrdom: IRRDocument = new RRDocument(),\n) {\n  function walk(node: Node, parentRRNode: IRRNode | null) {\n    const rrNode = buildFromNode(node, rrdom, domMirror, parentRRNode);\n    if (rrNode === null) return;\n    if (\n      // if the parentRRNode isn't a RRIFrameElement\n      parentRRNode?.nodeName !== 'IFRAME' &&\n      // if node isn't a shadow root\n      node.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE\n    ) {\n      parentRRNode?.appendChild(rrNode);\n      rrNode.parentNode = parentRRNode;\n      rrNode.parentElement = parentRRNode as RRElement;\n    }\n\n    if (node.nodeName === 'IFRAME') {\n      const iframeDoc = (node as HTMLIFrameElement).contentDocument;\n      iframeDoc && walk(iframeDoc, rrNode);\n    } else if (\n      node.nodeType === NodeType.DOCUMENT_NODE ||\n      node.nodeType === NodeType.ELEMENT_NODE ||\n      node.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE\n    ) {\n      // if the node is a shadow dom\n      if (\n        node.nodeType === NodeType.ELEMENT_NODE &&\n        (node as HTMLElement).shadowRoot\n      )\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        walk((node as HTMLElement).shadowRoot!, rrNode);\n      node.childNodes.forEach((childNode) => walk(childNode, rrNode));\n    }\n  }\n  walk(dom, null);\n  return rrdom;\n}\n\nexport function createMirror(): Mirror {\n  return new Mirror();\n}\n\n// based on Mirror from rrweb-snapshots\nexport class Mirror implements IMirror<RRNode> {\n  private idNodeMap: Map<number, RRNode> = new Map();\n  private nodeMetaMap: WeakMap<RRNode, serializedNodeWithId> = new WeakMap();\n\n  getId(n: RRNode | undefined | null): number {\n    if (!n) return -1;\n\n    const id = this.getMeta(n)?.id;\n\n    // if n is not a serialized Node, use -1 as its id.\n    return id ?? -1;\n  }\n\n  getNode(id: number): RRNode | null {\n    return this.idNodeMap.get(id) || null;\n  }\n\n  getIds(): number[] {\n    return Array.from(this.idNodeMap.keys());\n  }\n\n  getMeta(n: RRNode): serializedNodeWithId | null {\n    return this.nodeMetaMap.get(n) || null;\n  }\n\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n: RRNode) {\n    const id = this.getId(n);\n    this.idNodeMap.delete(id);\n\n    if (n.childNodes) {\n      n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\n    }\n  }\n  has(id: number): boolean {\n    return this.idNodeMap.has(id);\n  }\n\n  hasNode(node: RRNode): boolean {\n    return this.nodeMetaMap.has(node);\n  }\n\n  add(n: RRNode, meta: serializedNodeWithId) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n);\n    this.nodeMetaMap.set(n, meta);\n  }\n\n  replace(id: number, n: RRNode) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n, meta);\n    }\n    this.idNodeMap.set(id, n);\n  }\n\n  reset() {\n    this.idNodeMap = new Map();\n    this.nodeMetaMap = new WeakMap();\n  }\n}\n\n/**\n * Get a default serializedNodeWithId value for a RRNode.\n * @param id - the serialized id to assign\n */\nexport function getDefaultSN(node: IRRNode, id: number): serializedNodeWithId {\n  switch (node.RRNodeType) {\n    case RRNodeType.Document:\n      return {\n        id,\n        type: node.RRNodeType,\n        childNodes: [],\n      };\n    case RRNodeType.DocumentType: {\n      const doctype = node as IRRDocumentType;\n      return {\n        id,\n        type: node.RRNodeType,\n        name: doctype.name,\n        publicId: doctype.publicId,\n        systemId: doctype.systemId,\n      };\n    }\n    case RRNodeType.Element:\n      return {\n        id,\n        type: node.RRNodeType,\n        tagName: (node as IRRElement).tagName.toLowerCase(), // In rrweb data, all tagNames are lowercase.\n        attributes: {},\n        childNodes: [],\n      };\n    case RRNodeType.Text:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: (node as IRRText).textContent || '',\n      };\n    case RRNodeType.Comment:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: (node as IRRComment).textContent || '',\n      };\n    case RRNodeType.CDATA:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: '',\n      };\n  }\n}\n\n/**\n * Print the RRDom as a string.\n * @param rootNode - the root node of the RRDom tree\n * @param mirror - a rrweb or rrdom Mirror\n * @returns printed string\n */\nexport function printRRDom(rootNode: IRRNode, mirror: IMirror<IRRNode>) {\n  return walk(rootNode, mirror, '');\n}\nfunction walk(node: IRRNode, mirror: IMirror<IRRNode>, blankSpace: string) {\n  let printText = `${blankSpace}${mirror.getId(node)} ${node.toString()}\\n`;\n  if (node.RRNodeType === RRNodeType.Element) {\n    const element = node as IRRElement;\n    if (element.shadowRoot)\n      printText += walk(element.shadowRoot, mirror, blankSpace + '  ');\n  }\n  for (const child of node.childNodes)\n    printText += walk(child, mirror, blankSpace + '  ');\n  if (node.nodeName === 'IFRAME')\n    printText += walk(\n      (node as RRIFrameElement).contentDocument,\n      mirror,\n      blankSpace + '  ',\n    );\n  return printText;\n}\n\nexport { RRNode };\n\nexport { diff, createOrGetNode, ReplayerHandler } from './diff';\nexport * from './document';\n"],"names":["NodeType","Mirror","constructor","this","idNodeMap","Map","nodeMetaMap","WeakMap","getId","n","_a","id","getMeta","getNode","get","getIds","Array","from","keys","removeNodeFromMap","delete","childNodes","forEach","childNode","has","hasNode","node","add","meta","set","replace","oldNode","reset","toCSSText","style","properties","name","value","normalizedName","hyphenate","push","join","camelizeRE","CUSTOM_PROPERTY_REGEX","camelize","str","test","_","c","toUpperCase","hyphenateRE","toLowerCase","BaseRRNode","_args","ELEMENT_NODE","TEXT_NODE","childIterator","firstChild","nextSibling","contains","ownerDocument","parentNode","appendChild","_newChild","Error","insertBefore","_refChild","removeChild","_node","toString","BaseRRDocumentImpl","RRNodeClass","BaseRRDocument","args","super","DOCUMENT_NODE","RRNodeType","Document","textContent","documentElement","find","Element","tagName","body","head","implementation","firstElementChild","newChild","nodeType","DocumentType","some","s","child","parentElement","refChild","open","lastChild","close","write","content","publicId","doctype","createDocumentType","createDocument","_namespace","_qualifiedName","_doctype","qualifiedName","systemId","BaseRRDocumentTypeImpl","createElement","element","BaseRRElementImpl","createElementNS","_namespaceURI","createTextNode","data","text","BaseRRTextImpl","createComment","comment","BaseRRCommentImpl","createCDATASection","CDATASection","BaseRRCDATASectionImpl","DOCUMENT_TYPE_NODE","nodeName","result","classList","ClassList","attributes","class","newClassName","className","cssText","res","propertyDelimiter","split","item","tmp","length","trim","parseCSSText","setProperty","priority","removeProperty","getAttribute","setAttribute","attribute","setAttributeNS","removeAttribute","attachShadow","_init","shadowRoot","dispatchEvent","_event","attributeString","BaseRRMediaElementImpl","RRElementClass","play","paused","pause","Text","JSON","stringify","COMMENT_NODE","Comment","CDATA_SECTION_NODE","CDATA","classText","onChange","classNames","String","classes","indexOf","filter","parent","previousSibling","NAMESPACES","svg","xmlns","SVGTagMap","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","createdNodeSet","diff","oldTree","newTree","replayer","rrnodeMirror","mirror","afterAppend","WeakSet","setTimeout","sameNodeType","calibratedOldTree","createOrGetNode","replaceChild","nodeMatching","newMeta","oldElement","newRRElement","oldContentDocument","contentDocument","mode","diffChildren","oldAttributes","newAttributes","newValue","sn","isSVG","image","document","src","onload","ctx","getContext","drawImage","width","height","scrollLeft","scrollTop","diffProps","diffBeforeUpdatingChildren","scrollData","applyScroll","inputData","applyInput","oldMediaElement","newMediaRRElement","undefined","muted","volume","currentTime","playbackRate","loop","rrCanvasElement","rr_dataURL","canvasMutations","canvasMutation","applyCanvas","event","mutation","styleSheet","sheet","rules","applyStyleSheetMutation","diffAfterUpdatingChildren","oldChildren","newChildren","oldIdToIndex","indexInOld","oldStartIndex","oldEndIndex","newStartIndex","newEndIndex","oldStartNode","oldEndNode","newStartNode","newEndNode","e","console","warn","i","oldChild","nodeToMove","newNode","referenceRRNode","referenceNode","rrNode","domMirror","nodeId","node1","node2","rrdomMirror","node1Id","node2Id","RRDocument","RRNode","unserializedId","_unserializedId","UNSERIALIZED_STARTING_ID","createMirror","documentTypeNode","RRDocumentType","upperTagName","RRMediaElement","RRIFrameElement","RRCanvasElement","RRStyleElement","RRElement","commentNode","RRComment","sectionNode","RRCDATASection","textNode","RRText","destroyTree","buildFromNode","rrdom","parentRRNode","compatMode","documentType","elementNode","HTMLFormElement","rrElement","DOCUMENT_FRAGMENT_NODE","getDefaultSN","type","walk","blankSpace","printText","dom","createNodeMirror","iframeDoc","rootNode"],"mappings":"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"}